msgid ""
msgstr "Project-Id-Version: Game v4.7.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: Fri Jul 11 22:15:43 2025\n"
"Last-Translator: \n"
"Language-Team: none\n"
"Language: de\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit"

#: GameServer.RpcHandlers
msgid "level completed! 🎉"
msgstr ""

#: GameServer.RpcHandlers
msgid "level completed with warnings… 🎭"
msgstr ""

#: GameServer.RpcHandlers
msgid "intermediate goal solved! 🎉"
msgstr ""

#: Game.Doc.Definition
msgid "写像 `f` が単射（injective）であるとは, 次が成り立つこと：\n"
"\n"
"```\n"
"∀ a b, f a = f b → a = b\n"
"```"
msgstr ""

#: Game.Doc.Definition
msgid "写像 `f` が全射（surjective）であるとは, 次が成り立つこと：\n"
"\n"
"```\n"
"∀ b, ∃ a, f a = b\n"
"```"
msgstr ""

#: Game.Doc.Definition
msgid "写像が全単射（bijective）であるとは, 単射かつ全射であること."
msgstr ""

#: Game.Doc.Definition
msgid "写像 `f` が狭義単調増加（strictly monotonic）であるとは, 次が成り立つこと：\n"
"\n"
"```\n"
"∀ ⦃a b⦄, a < b → f a < f b\n"
"```"
msgstr ""

#: Game.Doc.Definition
msgid "`Function.RightInverse f g` は `LeftInverse g f` として定義される. \n"
"つまり, `∀ x, g (f x) = x` を意味する. \n"
"\n"
"残念ながら `RightInverse` ではなく `Function.RightInverse` と書く必要がある."
msgstr ""

#: Game.Doc.Definition
msgid "`LeftInverse g f` は `g ∘ f = id`, より正確には：\n"
"`∀ x, g (f x) = x` を意味する."
msgstr ""

#: Game.Doc.Definition
msgid "`HasRightInverse f` は, `f` が右逆写像を持つことを意味する. \n"
"\n"
"`HasLeftInverse f` は, `f` が左逆写像を持つことを意味する."
msgstr ""

#: Game.Doc.Definition
msgid "自己写像 `f : A → A` と元 `a : A` に対して, `IsFixedPt f a` は `f a = a` という主張."
msgstr ""

#: Game.Doc.Definition
msgid "写像 `f : A → A` に対して, `fixedPoints f : Set A` は `f` の不動点の集合."
msgstr ""

#: Game.Doc.Definition
msgid "部分集合 `A` と `B`（`A B : Set S`）に対して, `A ∪ B` はそれらの和集合."
msgstr ""

#: Game.Doc.Definition
msgid "部分集合 `A` と `B`（`A B : Set S`）に対して, `A ∩ B` はそれらの共通部分."
msgstr ""

#: Game.Doc.Definition
msgid "写像 `f : A → B` に対して, `range f` は `f` の像全体：\n"
"```\n"
"range f = {f a | a : A}\n"
"        = {  b | ∃ a, f a = b}\n"
"```"
msgstr ""

#: Game.Doc.Definition
msgid "写像 `f : A → B` に対して, `image f : Set A → Set B` は\n"
"部分集合に対する誘導写像で, `A` の部分集合を `f` による像に写す."
msgstr ""

#: Game.Doc.Definition
msgid "写像 `f : A → B` に対して, `preimage f : Set B → Set A` は\n"
"部分集合に対する誘導写像で, `B` の部分集合を `f` による逆像に写す."
msgstr ""

#: Game.Doc.Definition
msgid "写像 `f : A → B` と部分集合 `S`（`S ⊆ A`）に対して, \n"
"```\n"
"f '' S = {f a | a ∈ S}\n"
"       = {b | ∃ a ∈ S, f a = b}\n"
"```\n"
"は `f` による `S` の像."
msgstr ""

#: Game.Doc.Definition
msgid "写像 `f : A → B` と部分集合 `T`（`T ⊆ B`）に対して, \n"
"```\n"
"f ⁻¹' T = { a | f a ∈ T}\n"
"```\n"
"は `f` による `T` の逆像."
msgstr ""

#: Game.Doc.Definition
msgid "`fun x ↦ _` は無名関数を定義する記法. \n"
"例えば `fun (x : ℤ) ↦  -x` は `ℤ → ℤ` の否定を定義する."
msgstr ""

#: Game.Doc.Definition
msgid "`A : Set T` は `A` が `T` の部分集合であることを意味する."
msgstr ""

#: Game.Doc.Definition
msgid "部分集合 `A : Set T` と元 `a`（型 `T`）に対して, `a ∈ A` は\n"
"`a` が `A` に属することを意味する."
msgstr ""

#: Game.Doc.Definition
msgid "述語 `P : T → Prop` に対して, `{ a : T | P a } : Set P` は\n"
"`P` を満たす元からなる部分集合."
msgstr ""

#: Game.Doc.Definition
msgid "部分集合 `A, B : Set T` に対して, `A\\B` は `A` と `B` の差集合."
msgstr ""

#: Game.Doc.Definition
msgid "部分集合 `A, B : Set T` に対して, `A ⊆ B` は `A` が `B` に含まれることを意味する."
msgstr ""

#: Game.Doc.Definition
msgid "`∅ : Set T` は空集合."
msgstr ""

#: Game.Doc.Definition
msgid "`univ : Set T` は型 `T` の全ての元からなる部分集合."
msgstr ""

#: Game.Doc.Definition
msgid "有限部分集合 `A : Finset T` と元 `a : T` に対して, \n"
"`insert a A` は `A ∪ {a}` の別表記."
msgstr ""

#: Game.Doc.Definition
msgid "有限部分集合 `A : Finset T` と元 `a : T` に対して, \n"
"`erase A a` は `A \\ {a}` の別表記."
msgstr ""

#: Game.Doc.Definition
msgid "有限部分集合 `A : Finset T` に対して, `card A : ℕ` は `A` の要素数."
msgstr ""

#: Game.Doc.Definition
msgid "`n : ℕ` に対して, `Fin n` は集合 $\\{0, \\dots, n-1\\}$."
msgstr ""

#: Game.Doc.Definition
msgid "`Nonempty T` は型 `T` に元が存在することを意味する."
msgstr ""

#: Game.Doc.Definition
msgid "部分集合 `A : Set T` に対して, `Set.Finite A` は `A` が有限集合であることを意味する."
msgstr ""

#: Game.Doc.Definition
msgid "`(A : Prop)` は真偽が定まらない命題."
msgstr ""

#: Game.Doc.Definition
msgid "`A ∧ B`（「かつ」）は `A` と `B` がともに真である命題."
msgstr ""

#: Game.Doc.Definition
msgid "`A ∨ B`（「または」）は `A` または `B` の少なくとも一方が真である命題."
msgstr ""

#: Game.Doc.Definition
msgid "`A → B` は「`A` ならば `B`」という含意."
msgstr ""

#: Game.Doc.Definition
msgid "`A ↔ B` は `A` と `B` が同値であることを意味する."
msgstr ""

#: Game.Doc.Definition
msgid "存在量化子：`P : A → Prop` に対して, \n"
"`∃ a : A, P a` は `P a` を満たす `a` が存在することを意味する."
msgstr ""

#: Game.Doc.Definition
msgid "一意存在量化子：`P : A → Prop` に対して, \n"
"`∃! a : A, P a` は `P a` を満たす `a` が唯一存在することを意味する."
msgstr ""

#: Game.Doc.Definition
msgid "全称量化子：`P : A → Prop` に対して, \n"
"`∀ a : A, P a` は全ての `a` で `P a` が成り立つことを意味する."
msgstr ""

#: Game.Doc.Definition
msgid "`True : Prop` は常に真な命題."
msgstr ""

#: Game.Doc.Definition
msgid "`False : Prop` は常に偽な命題."
msgstr ""

#: Game.Doc.Definition
msgid "`¬ A` は `A` の否定."
msgstr ""

#: Game.Doc.Definition
msgid "等式に関する有用なタクティク：`rfl`, `rw`, `trans`"
msgstr ""

#: Game.Doc.Definition
msgid "不等式 `x ≠ y` は `¬ x = y` として定義される."
msgstr ""

#: Game.Doc.Definition
msgid "`Even n` は `n : ℕ` が偶数であるという主張：\n"
"```\n"
"∃ r : ℕ, n = r + r\n"
"```"
msgstr ""

#: Game.Doc.Definition
msgid "`Odd n` は `n : ℕ` が奇数であるという主張：\n"
"```\n"
"∃ k : ℕ, n = 2 * k + 1\n"
"```"
msgstr ""

#: Game.Doc.Definition
msgid "`n : ℕ` に対して, `Prime n` は `n` が素数であることを意味する."
msgstr ""

#: Game.Doc.Definition
msgid "`succ : ℕ → ℕ` は `n ↦ n + 1` という写像."
msgstr ""

#: Game.Doc.Definition
msgid "`n : ℤ`（非負整数）に対して, `n.toNat : ℕ` は同じ値を自然数として表す."
msgstr ""

#: Game.Doc.Definition
msgid "`x : ℝ` に対して, `|x|` は `x` の絶対値."
msgstr ""

#: Game.Doc.Definition
msgid "有限添字集合 `I : Finset T` に対して, `∑ i ∈ I, f i` は和 $\\sum_{i\\in I} f(i)$."
msgstr ""

#: Game.Doc.Definition
msgid "有限添字集合 `I : Finset T` に対して, `∏ i ∈ I, f i` は積 $\\prod_{i\\in I} f(i)$."
msgstr ""

#: Game.Doc.Definition
msgid "`P : MvPolynomial (Fin n) R` は `n` 変数多項式を表す."
msgstr ""

#: Game.Doc.Tactic
msgid "`apply`を使用すると, 含意`hAB : A → B`を適用できます：\n"
"\n"
"| 前          | タクティク       | 後                  |\n"
"|:------------|:----------------|:-------------------|\n"
"| `⊢ B`       | `apply hAB`     | `⊢ A`              |\n"
"| `h : A`     | `apply hAB at h`| `h : B`            |\n"
"\n"
"どちらの場合も, 含意`hAB`は仮定として与えられるか, 既知の補題として使用できます."
msgstr ""

#: Game.Doc.Tactic
msgid "タクティク`assumption`は, 仮定の1つが証明目標と完全に一致する場合に証明を完了します."
msgstr ""

#: Game.Doc.Tactic
msgid "タクティク`by_cases h : P`は, `P`が真か偽かの場合分けを開始します.\n"
"例えば, `by_cases h : a = b`は`a = b`と`a ≠ b`の場合に分けます.\n"
"\n"
"証明目標は複製され, 最初の「コピー」には仮定`(h : P)`が追加され,\n"
"2番目の「コピー」には仮定`(h : ¬P)`が追加されます."
msgstr ""

#: Game.Doc.Tactic
msgid "タクティク`by_contra h`は矛盾による証明を開始します.\n"
"現在の証明目標が`P`の場合, `by_contra h`は新しい仮定`(h : ¬P)`を生成し,\n"
"証明目標を`False`に設定します.\n"
"\n"
"## 関連タクティク\n"
"* 矛盾証明の最後には通常`contradiction`が使用されます：\n"
"  このタクティクは, 明らかに矛盾する2つの仮定を見つけた場合に証明を完了します.\n"
"* 証明目標が`A → B`の形式の場合, `contrapose`を使用して対偶による証明を開始できます."
msgstr ""

#: Game.Doc.Tactic
msgid "`change t`は証明目標を`t`に変更します. 前提として, `t`と古い証明目標が定義的に等しい必要があります.\n"
"これは特に, タクティクが証明目標が実際に必要な項と定義的に等しいことを認識しない場合に役立ちます.\n"
"\n"
"## 例\n"
"現在の証明状況：\n"
"```\n"
"b: ℝ\n"
"⊢ 1 • b = b\n"
"```\n"
"スカラー乗算が`fun (a : ℚ) (r : ℝ) => ↑a * r`と定義されている場合,\n"
"`change (1 : ℚ) * b = b`で証明目標を書き換え, その後乗算に関する補題で証明できます."
msgstr ""

#: Game.Doc.Tactic
msgid "`h : ∃ (b : B), P b`の形式の仮定は,\n"
"`choose b hb using h`で`b : A`と`hb : P b`に分解できます.\n"
"\n"
"より一般的に, `choose`を使用して選択公理で要素を選択できます：\n"
"`h : ∀ (a : A), ∃ (b : B), P a b`の形式の仮定から,\n"
"`choose f hf using h`は写像`f : A → B`と仮定`hf : ∀ (a : A), P a (f a)`を抽出します."
msgstr ""

#: Game.Doc.Tactic
msgid "タクティク`constructor`は証明目標を構成要素に分割します：\n"
"\n"
"| 前          | 後                  |\n"
"|:------------|:-------------------|\n"
"| `⊢ A ∧ B`   | `⊢ A`と`⊢ B`       |\n"
"| `⊢ A ↔ B`   | `⊢ A → B`と`⊢ B → A` |\n"
"\n"
"## 関連タクティク\n"
"* 仮定は`obtain`で構成要素に分解できます.\n"
"* `A ∨ B`を証明するには, `left`または`right`でどちらかを選択する必要があります."
msgstr ""

#: Game.Doc.Tactic
msgid "タクティク`contradiction`は, 仮定に矛盾がある場合に証明を完了します.\n"
"矛盾は例えば以下のように見えます：\n"
"\n"
"* `h : n ≠ n`\n"
"* `h : A`と`h' : ¬A`\n"
"* `h : False`\n"
"\n"
"## 関連タクティク\n"
"通常, `contradiction`は`by_contra`で開始された矛盾証明を完了するために使用されます."
msgstr ""

#: Game.Doc.Tactic
msgid "タクティク`contrapose`は`A → B`の形式の証明目標を`¬B → ¬A`に変更し,\n"
"対偶による証明を開始します.\n"
"\n"
"## 関連タクティク\n"
"`revert h`は`contrapose`を使用する前に仮定を含意の前提として記述するのに役立ちます."
msgstr ""

#: Game.Doc.Tactic
msgid "タクティク`exact h`は, 項`h`が証明目標と一致する場合に証明を完了します."
msgstr ""

#: Game.Doc.Tactic
msgid "与えられた集合の2つの部分集合は, 同じ要素を持つ場合に等しいです.\n"
"証明目標に`A = B`（`A B : Set T`）がある場合,\n"
"`ext x`は証明目標を`x ∈ A ↔ x ∈ B`に変換します."
msgstr ""

#: Game.Doc.Tactic
msgid "`fin_cases i`は, `i`が有限型の場合に場合分けを実行します.\n"
"\n"
"## 詳細\n"
"`fin_cases i`は特に`(i : Fin n)`に対して有用で,\n"
"有限次元ベクトル空間のインデックスとして使用できます."
msgstr ""

#: Game.Doc.Tactic
msgid "同じ値域と定義域を持つ2つの関数は,\n"
"定義域のすべての要素で同じ値を取る場合に等しいです.\n"
"`f = g`（`f g : X → Y`）の形式の証明目標は,\n"
"`funext x`で`f x = g x`に変換されます."
msgstr ""

#: Game.Doc.Tactic
msgid "`generalize`は証明目標を一般化できます.\n"
"例えば, `generalize h : a = b`は証明目標のすべての`a`を`b`に置き換えます.\n"
"\n"
"## 例\n"
"`Even x ∨ ¬Even x`の目標は,\n"
"`generalize h : (Even x) = A`で`A ∨ ¬A`に変換できます."
msgstr ""

#: Game.Doc.Tactic
msgid "`have h : P`は中間結果を導入します.\n"
"その後, この中間結果を証明してからメインの証明を続行します.\n"
"\n"
"## 関連タクティク\n"
"`suffices h : P`も同様ですが, まずメインの証明を続行し,\n"
"最後に中間結果を証明します."
msgstr ""

#: Game.Doc.Tactic
msgid "`if … then … else`を使用して, 2つの定義分岐を持つ関数を定義できます.\n"
"\n"
"## 関連タクティク\n"
"* `h : A`がある場合, `rw [if_pos h]`で`if A then B else C`を`B`に簡約できます.\n"
"* `h : ¬ A`がある場合, `rw [if_neg h]`で`if A then B else C`を`C`に簡約できます."
msgstr ""

#: Game.Doc.Tactic
msgid "タクティク`induction n`は`n`に関する帰納法による証明を実行します.\n"
"`induction n with d hd`で帰納変数（`d`）と帰納仮定（`hd`）に名前を付けられます.\n"
"\n"
"## ゲーム内の変更\n"
"ゲーム外では, `induction`は`induction'`と呼ばれ,\n"
"`0`は`Nat.zero`, `d + 1`は`Nat.succ d`と書かれます."
msgstr ""

#: Game.Doc.Tactic
msgid "タクティク`intro`は`A → B`または`∀ x, P x`の証明目標に使用されます.\n"
"\n"
"| 前          | タクティク     | 後                  |\n"
"|:------------|:-------------|:-------------------|\n"
"| `⊢ A → B`   | `intro h`    | `h : A`, `⊢ B`     |\n"
"| `⊢ ∀ x, P x`| `intro x hx` | `x : X`, `hx : P x`|\n"
"\n"
"## 関連タクティク\n"
"`revert h`は`intro h`の逆を行います."
msgstr ""

#: Game.Doc.Tactic
msgid "証明目標が`A ∨ B`の場合, `left`で左側を示すことを選択します.\n"
"\n"
"## 関連タクティク\n"
"`right`で右側を選択できます."
msgstr ""

#: Game.Doc.Tactic
msgid "タクティク`let`は一時的な定義を導入します.\n"
"例えば, `let x : ℕ := 5 ^ 2`です."
msgstr ""

#: Game.Doc.Tactic
msgid "タクティク`linarith`は, 与えられた等式や不等式から線形の等式や不等式が導かれることを示せます."
msgstr ""

#: Game.Doc.Tactic
msgid "タクティク`omega`は, `ℕ`または`ℤ`における線形の等式や不等式が,\n"
"与えられた等式や不等式から導かれることを示せます."
msgstr ""

#: Game.Doc.Tactic
msgid "タクティク`push_neg`は否定を量化子の前に移動します：\n"
"\n"
"| 前          | 後              |\n"
"|:------------|:---------------|\n"
"| `¬∀ x, P x` | `∃ x, ¬P x`    |\n"
"| `¬∃ x, P x` | `∀ x, ¬P x`    |\n"
"\n"
"## 関連タクティク\n"
"`not_forall`と`not_exists`は`rw`で個別に適用できます."
msgstr ""

#: Game.Doc.Tactic
msgid "タクティク`obtain`は仮定を構成要素に分解します:\n"
"\n"
"| 前                | タクティク               | 後                          |\n"
"|:------------------|:-----------------------|:---------------------------|\n"
"| `h : A ∧ B`       | `obtain ⟨h₁, h₂⟩ := h` | `h₁ : A`, `h₂ : B`          |\n"
"| `h : A ↔ B`       | `obtain ⟨h₁, h₂⟩ := h` | `h₁ : A → B`, `h₂ : B → A`  |\n"
"| `h : Nonempty X`  | `obtain ⟨x⟩ := h`      | `x : X`                     |\n"
"| `h : ∃ x : X, P x`| `obtain ⟨x, hx⟩ := h`  | `x : X`, `hx : P x`         |\n"
"| `h : A ∨ B`       | `obtain h \\| h := h`   | `h : A`または`h : B`の目標  |"
msgstr ""

#: Game.Doc.Tactic
msgid "`refine' { .. }`は構造体（例：$R$-加群）をタクティクモードで個々の証明目標に分割するために必要です."
msgstr ""

#: Game.Doc.Tactic
msgid "タクティク`revert h`は仮定`h`を含意の前提として証明目標に追加します.\n"
"\n"
"## 関連タクティク\n"
"`intro h`は`revert h`の逆を行います."
msgstr ""

#: Game.Doc.Tactic
msgid "タクティク`rfl`は`X = X`を証明します. 正確には, `A`と`B`が定義的に等しい場合に`A = B`を証明します."
msgstr ""

#: Game.Doc.Tactic
msgid "証明目標が`A ∨ B`の場合, `right`で右側を示すことを選択します.\n"
"\n"
"## 関連タクティク\n"
"`left`で左側を選択できます."
msgstr ""

#: Game.Doc.Tactic
msgid "タクティク`ring`は`+, -, *, ^`の操作を含む等式を半環（特にℕ, ℤ, ℚ, ℝ）で証明します."
msgstr ""

#: Game.Doc.Tactic
msgid "等式`h : X = Y`または同値`h : X ↔ Y`がある場合, `rw [h]`で証明目標の`X`を`Y`に置き換えられます.\n"
"\n"
"## バリエーション\n"
"* `rw [←h]`は`h`を逆に適用し, `Y`を`X`に置き換えます.\n"
"* `rw [h] at h₂`は仮定`h₂`で置換を行います.\n"
"* `nth_rw k [h]`は`k`番目の出現を置換します."
msgstr ""

#: Game.Doc.Tactic
msgid "タクティク`simp`は多くの補題を適用して式を簡約します.\n"
"\n"
"## バリエーション\n"
"* `simp [h]`は追加で仮定`h`を使用します.\n"
"* `simp only [h,f,g]`は`h`, `f`, `g`のみを使用します."
msgstr ""

#: Game.Doc.Tactic
msgid "`simp_rw [h₁, h₂, h₃]`は各補題を可能な限り適用しますが, `rw`よりも量化子の下でうまく機能します."
msgstr ""

#: Game.Doc.Tactic
msgid "`specialize h a₁ a₂`は`have h := h a₁ a₂`と同等です：仮定`h : ∀ m₁ m₂, P m₁ m₂`を`h : P a₁ a₂`に置き換えます."
msgstr ""

#: Game.Doc.Tactic
msgid "`suffices h : P`は, 証明目標が`P`から導かれることを示す証明セクションを開始します.\n"
"その後, `P`を証明します.\n"
"\n"
"## 関連タクティク\n"
"`have h : P`も同様ですが, まず`P`を証明してからメインの証明を続行します."
msgstr ""

#: Game.Doc.Tactic
msgid "タクティク`symm`は証明目標の等式（`=`）または同値（`↔`）の両側を交換します.\n"
"\n"
"## バリエーション\n"
"* `symm at h`は仮定`h`で操作します.\n"
"* `h.symm`は`symm at h`の結果です."
msgstr ""

#: Game.Doc.Tactic
msgid "タクティク`trans`は等式または同値に中間ステップを挿入します.\n"
"\n"
"| 前          | 後                  |\n"
"|:------------|:-------------------|\n"
"| `⊢ A = C`   | `⊢ A = B`と`⊢ B = C`|\n"
"| `⊢ A ↔ C`   | `⊢ A ↔ B`と`⊢ B ↔ C`|"
msgstr ""

#: Game.Doc.Tactic
msgid "タクティク`decide`は単純なアルゴリズムで決定可能な命題を証明します.\n"
"例えば：\n"
"- `Even 4`\n"
"- `2 ≤ 5`\n"
"- `4 ≠ 6`\n"
"- `Prime 7`"
msgstr ""

#: Game.Doc.Tactic
msgid "`unfold F`は証明目標で定義`F`を展開します.\n"
"`unfold F at h`は仮定`h`で同じことを行います.\n"
"\n"
"## 関連タクティク\n"
"`unfold F`と`simp only [F]`はほぼ同じです."
msgstr ""

#: Game.Doc.Tactic
msgid "証明目標が`∃x, P x`の場合, `use n`で具体的な要素を指定できます."
msgstr ""

#: Game.Doc.Tactic
msgid "タクティク`tauto`は論理的同語反復を証明します.\n"
"\n"
"## 関連タクティク\n"
"場合によっては, `generalize`で証明目標を抽象化する必要があります."
msgstr ""

#: Game.Levels.Logo.L01_Tauto
msgid "Automatisierung"
msgstr ""

#: Game.Levels.Logo.L01_Tauto
msgid "ちょうどあなたは女王*Logisinde*の惑星にいます. 彼女は前置きなしに本題に入ります:\n"
"\n"
"**Logisinde**: 異世界からの尊き客人よ, ひとつ質問をさせてください. なぜ…ということが成り立つのでしょう? \n"
"\n"
"そして彼女は紙切れに何かを走り書きします: 上部にいくつかの仮定, 下部に結論. \n"
"その間にあなたは証明を記入する必要があるようです. \n"
"あなたはRoboを困った様子で見ます."
msgstr ""

#: Game.Levels.Logo.L01_Tauto
msgid ""
msgstr ""

#: Game.Levels.Logo.L01_Tauto
msgid "**Robo**: これはとても簡単です. `«{A}» «{B}» «{C}» : Prop`とは彼女が言っているのは:\n"
"`«{A}»`, `«{B}»`, `«{C}»`は任意の命題(*propositions*)です. \n"
"そして`→`は⇒, つまり「ならば」を意味します. 他の記号は知ってるよね? \n"
"\n"
"**あなた**: えーと, はい. でもそれでもちょっと考えないと. \n"
"\n"
"**Robo**: (小声で) ただこれは恒真式だと言っちゃえばいいよ. \n"
"\n"
"**あなた**: 本当に? \n"
"\n"
"**Robo**: はい. ただ`tauto`と書くだけ. \n"
"\n"
"**Robo**: さあやってみて…"
msgstr ""

#: Game.Levels.Logo.L01_Tauto
msgid "**Logisinde**: (少し当惑して) ええ, 厳密には正しいです. \n"
"でも*この*惑星ではそれでうまくいくと思わないでください! \n"
"私の家臣は`tauto`を理解しません. もっと努力が必要ですよ."
msgstr ""

#: Game.Levels.Logo.L02_Rfl
msgid "Aller Anfang ist... ein Einzeiler?"
msgstr ""

#: Game.Levels.Logo.L02_Rfl
msgid "その間に, 質問をしたい家臣たちの長い列がすでにできていました. Logisindeが最初の者を手招きします. 彼は咳払いをします. \n"
"\n"
"**家臣**: なぜ`42 = 42`なのですか? \n"
"\n"
"あなたは呆然とした表情で彼を見ます. \n"
"彼は再びそれを書き留めます."
msgstr ""

#: Game.Levels.Logo.L02_Rfl
msgid "**Robo**: それは明らかです. 等式が*反射的*であることを思い出させればいいのです. `rfl`を試してみてください."
msgstr ""

#: Game.Levels.Logo.L02_Rfl
msgid "**家臣**: ああ, その通りです. はい, まったく正しいです. 私はいつもそれを忘れてしまいます. `rfl`, `rfl`, `rfl`…"
msgstr ""

#: Game.Levels.Logo.L03_Assumption
msgid "Annahmen"
msgstr ""

#: Game.Levels.Logo.L03_Assumption
msgid "最初の家臣がまだ「`rfl`, `rfl`, `rfl`」とつぶやいている間に, 次の家臣が前に出てきます.\n"
"それは恥ずかしがり屋で, ただ書き留めるだけです."
msgstr ""

#: Game.Levels.Logo.L03_Assumption
msgid "**Robo**: `«{n}» : ℕ` は, `«{n}»` が自然数であることを意味します.\n"
"\n"
"**あなた**: それならなぜ `«{n}» ∈ ℕ` と書かないの?\n"
"\n"
"\n"
"**Robo**: ここはみんな変だから…後でゆっくり説明するよ. 今はまず問題を解読したいんだ.\n"
"\n"
"**Robo**: つまり, `«{h₁}»`, `«{h₂}»`, `«{h₃}»` は, それぞれ `n < 10`, `1 < n`, `n ≠ 5` という仮定の名前だ. 証明すべきは `1 < n`.\n"
"\n"
"**あなた**: でもそれは仮定の一つじゃない?\n"
"\n"
"**Robo**: そうだね.\n"
"\n"
"**あなた**: ???\n"
"\n"
"**Robo**: それを明確に伝えないといけないんだ. `assumption` を使ってみて."
msgstr ""

#: Game.Levels.Logo.L03_Assumption
msgid "**家臣**: すごい! この問題でどれだけ頭を悩ませたか!"
msgstr ""

#: Game.Levels.Logo.L04_Assumption
msgid "Logische Aussagen"
msgstr ""

#: Game.Levels.Logo.L04_Assumption
msgid "3番目の家臣が次の問題を持ってやってきました."
msgstr ""

#: Game.Levels.Logo.L04_Assumption
msgid "**Robo**: ここで`«{A}» : Prop`は再び, `«{A}»`が何らかの命題であることを意味します. \n"
"そして`«{hA}»`は`«{A}»`が真であるという仮定の名前です. \n"
"\n"
"**あなた**: そしてこの仮定の下で, 今`«{A}»`を証明する必要があるのですか? \n"
"\n"
"**Robo**: はい. どうすればいいか, もう自分でわかりますよね?"
msgstr ""

#: Game.Levels.Logo.L04_Assumption
msgid "**Robo**: 先ほどと全く同じです:\n"
"証明すべき命題自体が仮定の中に含まれています. \n"
"ですから, `assumption`が再び機能するでしょう."
msgstr ""

#: Game.Levels.Logo.L04_Assumption
msgid "**Robo**: 以前と同じように, 証明される文自体が仮定の一つなのです. \n"
"だから, `assumption`もまた機能する."
msgstr ""

#: Game.Levels.Logo.L04_Assumption
msgid "**家臣**: あっという間でした. 素晴らしい! どうもありがとう."
msgstr ""

#: Game.Levels.Logo.L05_True
msgid "True or False"
msgstr ""

#: Game.Levels.Logo.L05_True
msgid "次の順番の家臣は悪戯好きだ."
msgstr ""

#: Game.Levels.Logo.L05_True
msgid "**Robo**: この`True`は特別な命題で, 常に無条件に真となる命題です. \n"
"\n"
"**あなた**: では, 具体的に何を証明すればいいのですか? \n"
"\n"
"**Robo**: おそらく何もありません. `decide`を試してみてください."
msgstr ""

#: Game.Levels.Logo.L05_True
msgid "**悪戯好き**: あなたがまともな方かどうか確かめたかっただけです…\n"
"\n"
"**あなた** *(Roboに向かって)*: この`decide`をいつも使えないのですか? \n"
"\n"
"**Robo**: いいえ, `decide`は特別な状況, つまり命題が真かどうかを決定する簡単なアルゴリズムがある場合にのみ機能します."
msgstr ""

#: Game.Levels.Logo.L06_Not
msgid "Not"
msgstr ""

#: Game.Levels.Logo.L06_Not
msgid "悪戯っ子にはもう一人姉妹がいるようだ."
msgstr ""

#: Game.Levels.Logo.L06_Not
msgid "**Robo**: この記号`¬`は否定を意味します. つまり命題`(A : Prop)`が\n"
"真ならば, `¬A`は偽となり, その逆もまた然りです. \n"
"\n"
"**あなた**: そして`False`はおそらく常に偽となる命題なのですか? \n"
"\n"
"**Robo**: はい, その通りです. \n"
"\n"
"**あなた**: これは結局`decide`ではないのですか? \n"
"\n"
"**Robo**: 試してみてください!"
msgstr ""

#: Game.Levels.Logo.L06_Not
msgid "姉妹は笑いながら兄の後を追いかけていった."
msgstr ""

#: Game.Levels.Logo.L07_Contradiction
msgid "Aus Falschem folgt vieles."
msgstr ""

#: Game.Levels.Logo.L07_Contradiction
msgid "次に3人の難癖つけがやってきます. 最初の者は次の問題を抱えています:"
msgstr ""

#: Game.Levels.Logo.L07_Contradiction
msgid "**あなた**: これを正しく読むと, `«{A}»`は命題で,\n"
"さらに`«{h}»`という仮定があります. それは…\n"
"\n"
"**Robo**: …`False`が成り立つと言っています.\n"
"\n"
"**あなた**: `False`は決して成り立たないんじゃないですか?\n"
"\n"
"**Robo**: はい, その通りです. この仮定は`False`, つまり偽です.\n"
"偽の仮定からは, どんなことでも証明できるのはご存知でしょう!\n"
"特に求められている命題`«{A}»`もです.\n"
"\n"
"**あなた**: で, どうやってこのFormalosophenに説明すればいいの?\n"
"\n"
"**Robo**: 一般的に成り立つ仮定`True`と彼の仮定`False`の間に矛盾があることを指摘する必要があると思います. `contradiction`を試してみてください."
msgstr ""

#: Game.Levels.Logo.L07_Contradiction
msgid "最初の難癖つけはどうやら満足したようです.\n"
"\n"
"**あなた** これは背理法だったの?\n"
"\n"
"**Robo** いえいえ, 背理法はもっと違うものです. ここでの論点は, 仮定の中に`contradiction`があるので, どんな命題でも導かれるということです."
msgstr ""

#: Game.Levels.Logo.L08_Contradiction
msgid "Aus Falschem folgt vieles."
msgstr ""

#: Game.Levels.Logo.L08_Contradiction
msgid "2番目の反逆者の登場."
msgstr ""

#: Game.Levels.Logo.L08_Contradiction
msgid ""
msgstr ""

#: Game.Levels.Logo.L08_Contradiction
msgid "**あなた**: `«{n}» ≠ «{n}»`も矛盾してるんじゃない? \n"
"\n"
"**Robo**: 試してみて!"
msgstr ""

#: Game.Levels.Logo.L08_Contradiction
msgid "**あなた**: うん, うまくいったみたい. \n"
"\n"
"**あなた**: でもまだちょっと怪しい気がする. \n"
"任意の自然数が37に等しいことを証明しちゃった? \n"
"\n"
"**Robo**: いやいや, そうじゃない. 自分自身と等しくない任意の数が37に等しいってこと. \n"
"そして38にも, 39にも, …\n"
"\n"
"**あなた**: わかったわかった, 理解したよ."
msgstr ""

#: Game.Levels.Logo.L09_Contradiction
msgid "Aus Falschem folgt vieles."
msgstr ""

#: Game.Levels.Logo.L09_Contradiction
msgid "三番目の反逆者の登場."
msgstr ""

#: Game.Levels.Logo.L09_Contradiction
msgid ""
msgstr ""

#: Game.Levels.Logo.L09_Contradiction
msgid "**あなた** また仮定の中に矛盾があるの?\n"
"\n"
"**Robo**: だんだんコツがわかってきたみたいだね"
msgstr ""

#: Game.Levels.Logo.L09_Contradiction
msgid "**Robo**: よくできました. この問題では, 矛盾がどこにあるのか少し明白でしたね:\n"
"仮定 `n ≠ 10` は `n = 10` の否定そのものです.\n"
"`≠` は常に `¬(· = ·)` と読む必要があります."
msgstr ""

#: Game.Levels.Logo.L10_And
msgid "Und"
msgstr ""

#: Game.Levels.Logo.L10_And
msgid "次に並んでいるFormalosophenが, すでに質問を用意して待っていました.\n"
"彼はそれを私たちに提示し, 座って編み物を始めます."
msgstr ""

#: Game.Levels.Logo.L10_And
msgid ""
msgstr ""

#: Game.Levels.Logo.L10_And
msgid "**あなた**: ええと, 私たちには2つの前提があります: `«{A}»`が成り立ち, `«{B}»`も成り立つ. そして証明すべきは\n"
"`«{A}» かつ «{B}»`が成り立つことです. このFormalosophenたちには本当にうんざりする.\n"
"\n"
"**Robo**: 今回は, 証明目標を2つの部分に分ける必要があります. `constructor`を試してみてください.\n"
"\n"
"**あなた**: `destructor`ではなく??\n"
"\n"
"**Robo**: いいえ, `constructor`です. 混乱するのはわかりますが,\n"
"ここでは複数の部分から主張を構築できるのでこう呼ばれています."
msgstr ""

#: Game.Levels.Logo.L10_And
msgid "**Robo**: 見てください, これは魔法の紙です.\n"
"突然, 2つの証明目標ができました.\n"
"ここにあるのは`«{B}»`という目標です.\n"
"それぞれの目標を達成する方法はもうわかっていると思います.\n"
"目標はそれぞれ*仮定*の中に書かれています."
msgstr ""

#: Game.Levels.Logo.L10_And
msgid "**Robo**: 素晴らしい!\n"
"\n"
"彼はこれらの質問を楽しんでいるようです.\n"
"\n"
"**Robo**: 「編集モード」と書かれたこのレバーは本物だと思う?\n"
"それともただの絵? 試してみて!"
msgstr ""

#: Game.Levels.Logo.L11_And
msgid "Und"
msgstr ""

#: Game.Levels.Logo.L11_And
msgid "蛇のような列も, 徐々に短くなっていきます. 次の編み物をしているFormalosophenが, 次のような要望を書いた紙を持っています."
msgstr ""

#: Game.Levels.Logo.L11_And
msgid "**あなた**: そろそろ仮定を分解する必要がありそうだ.\n"
"\n"
"**Robo**: はい, その通りです. 最も簡単な方法は`obtain ⟨h₁, h₂⟩ := «{h}»`を使うことです.\n"
"\n"
"**あなた**: 待って, どうやって書けばいいんだっけ?\n"
"\n"
"**Robo**: 角括弧は`\\<`と`\\>`で書くか, まとめて`\\<>`と書きます.\n"
"h₁は単に`h\\1`と書けます. でも`h₁`や`h₂`の代わりに他の名前を使っても構いません.\n"
"例えば`obtain ⟨hA, hBC⟩ := «{h}»`のように."
msgstr ""

#: Game.Levels.Logo.L11_And
msgid "**Robo**: だいぶ良くなってきました! もう一度やってみましょう!"
msgstr ""

#: Game.Levels.Logo.L11_And
msgid "**Robo**: あなたはその証明を*仮定*の中に持っています."
msgstr ""

#: Game.Levels.Logo.L11_And
msgid "**Robo**: ちなみに, これは直接ネストして書くこともできました:\n"
"`obtain ⟨h₁, h₂ , h₃⟩ := h`."
msgstr ""

#: Game.Levels.Logo.L12_Or
msgid "Oder"
msgstr ""

#: Game.Levels.Logo.L12_Or
msgid "次の方どうぞ…"
msgstr ""

#: Game.Levels.Logo.L12_Or
msgid "**あなた** また証明目標を分解しなきゃいけないの?\n"
"\n"
"**Robo** いいえ, もっと簡単です. ORの命題を証明するときは, 左側か右側のどちらかを証明すればいいんです.\n"
"\n"
"**あなた** それで, Formalosophenにどっちを証明したいかどう説明すれば? もちろん`«{A}»`を証明したいんだけど!\n"
"\n"
"**Robo** `left`か`right`で. わかりやすいでしょ?"
msgstr ""

#: Game.Levels.Logo.L12_Or
msgid "**Robo** 左右が苦手だなんて知らなかったわ. もう一度試してみて."
msgstr ""

#: Game.Levels.Logo.L12_Or
msgid "このFormalosophenも満足して去っていきました."
msgstr ""

#: Game.Levels.Logo.L13_Or
msgid "Oder"
msgstr ""

#: Game.Levels.Logo.L13_Or
msgid "次をお願いします…"
msgstr ""

#: Game.Levels.Logo.L13_Or
msgid ""
msgstr ""

#: Game.Levels.Logo.L13_Or
msgid "**Robo** ほら, 仮定を指で触ると括弧の付け方が表示されるよ. すごいでしょ…\n"
"\n"
"**あなた** ああ, なるほど `(«{A}» ∧ «{B}») ∨ «{A}»` ってことね!\n"
"\n"
"**あなた** この流れにはうんざりしてきたわ：\n"
"最初は目標に「かつ」, 次に仮定に「かつ」, その次は目標に「または」,\n"
"そして今度は仮定に「または」… みんなで相談して決めてるみたい!\n"
"\n"
"**Robo** まあ楽しませてあげようよ.\n"
"もうすぐ終わるし, もっと面白い惑星に行けるんだから.\n"
"\n"
"**あなた** じゃあ, また `obtain …` を使うの?\n"
"\n"
"**Robo** そうだよ. でも今回は `obtain ⟨h₁, h₂⟩ := «{h}»` じゃなくて `obtain h | h := «{h}»` だよ"
msgstr ""

#: Game.Levels.Logo.L13_Or
msgid "**Robo**\n"
"今度は目標を2回証明する必要がある：\n"
"まず左側 `«{A}» ∧ «{B}»` を仮定した場合と,\n"
"右側 `«{A}»` を仮定した場合だ.\n"
"ここでは左側が真だと仮定している"
msgstr ""

#: Game.Levels.Logo.L13_Or
msgid "**Robo** 仮定中の「かつ」の扱い方は\n"
"もう知ってるよね：\n"
"`obtain ⟨h₁, h₂⟩ := «{h}»`. 括弧は `\\<>` で書くんだったね"
msgstr ""

#: Game.Levels.Logo.L13_Or
msgid "**Robo** 今度は `(«{A}» ∧ «{B}») ∨ «{A}»` の右側の仮定,\n"
"つまり `«{A}»` が真だとした場合の証明だよ"
msgstr ""

#: Game.Levels.Logo.L13_Or
msgid "**あなた** よし, これで彼は満足したみたい. あと1人だけ…\n"
"ここまでに学んだLeanのことを簡単にまとめてくれない?\n"
"\n"
"Roboは嬉しそうに輝いた. 今までで*初めて*あなたが彼にこんなに頼ってきた.\n"
"\n"
"**Robo** もちろん, 見ててね!\n"
"\n"
"## 表記法 / 用語\n"
"\n"
"|               | 説明                                                                 |\n"
"|:--------------|:---------------------------------------------------------------------|\n"
"| *Goal*        | 現在証明すべきこと                                                  |\n"
"| *仮定*        | 利用可能なオブジェクトや結果                                        |\n"
"| *tactic*  | 証明中のコマンド. 証明ステップに相当                                 |\n"
"| `ℕ`           | 自然数の型                                                          |\n"
"| `0, 1, 2, …`  | 具体的な自然数                                                      |\n"
"| `=`           | 等号                                                               |\n"
"| `≠`           | 不等号. `¬(·=·)`の略記                                             |\n"
"| `Prop`        | 論理命題の型                                                       |\n"
"| `True`        | 無条件に真となる論理命題 `(True : Prop)`                           |\n"
"| `False`       | 無条件に偽となる論理命題 `(False : Prop)`                          |\n"
"| `¬`           | 論理否定                                                           |\n"
"| `∧`           | 論理AND                                                            |\n"
"| `∨`           | 論理OR                                                             |\n"
"| `(n : ℕ)`     | 自然数                                                              |\n"
"| `(A : Prop)`  | 論理命題                                                           |\n"
"| `(ha : A)`    | 命題 `(A : Prop)` が真である証明                                   |\n"
"| `(h : A ∧ B)` | 仮定で, 名前が `h` と付けられたもの                                |\n"
"\n"
"\n"
"## tactic\n"
"\n"
"実際に使う必要のある言葉をまとめて `tactic` と呼ぶ.\n"
"この惑星で使ったtacticをすべて紹介する：\n"
"\n"
"|    | tactic                  | 例                                                 |\n"
"|:---|:----------------------------|:---------------------------------------------------|\n"
"| 1  | `rfl`                       | `A = A` を証明                                    |\n"
"| 2  | `assumption`                | Goalを仮定から探す                                |\n"
"| 3  | `contradiction`             | 矛盾を探す                                        |\n"
"| 4  | `decide`                    | 命題の真偽を判定しようとする                      |\n"
"| 5  | `constructor`               | Goal中のANDを分割                                 |\n"
"| 6  | `left`/`right`              | Goal中のORの片側を証明                            |\n"
"| 7ᵃ | `obtain ⟨h₁, h₂⟩ := h`      | 仮定中のANDを分割                                 |\n"
"| 7ᵇ | `obtain h := h \\| h`       | 仮定中のORをケース分け                            |\n"
"\n"
"**あなた** どうしてこんなに詳しいの?\n"
"\n"
"**Robo** さあね. 多分最初から入ってたんだと思う"
msgstr ""

#: Game.Levels.Logo.L14_Summary
msgid "Zusammenfassung"
msgstr ""

#: Game.Levels.Logo.L14_Summary
msgid "ここで, この状況で最も重要な4つの戦術をもう一度示しておきます.\n"
"\n"
"| (概要) | AND (`∧`)               | OR (`∨`)               |\n"
"|:------------|:-------------------------|:------------------------|\n"
"| 前提     | `obtain ⟨h₁, h₂⟩ := {h}`   | `obtain h \\| h := {h}`   |\n"
"| 目標        | `constructor`            | `left`/`right`\n"
"\n"
"最後の家臣が前に出てきます. 彼女の訴えはこれまでのものより少し複雑です.\n"
"\n"
"**Robo** 学んだことをすべて使ってみてください.       |"
msgstr ""

#: Game.Levels.Logo.L14_Summary
msgid "**Robo**: まず前提 «{h}» を `obtain ⟨⟩ := «{h}»` で分割するといいよ"
msgstr ""

#: Game.Levels.Logo.L14_Summary
msgid "**Robo**: これでゴールの `∧` を `constructor` で処理できるよ"
msgstr ""

#: Game.Levels.Logo.L14_Summary
msgid "**Robo**: ここで前提 «{h}» をもう一度 `obtain` で分割するといいかも"
msgstr ""

#: Game.Levels.Logo.L14_Summary
msgid "**Robo**: この順序の欠点は, 各Subゴールで `obtain ⟨⟩ := h` を呼ぶ必要があることだね"
msgstr ""

#: Game.Levels.Logo.L14_Summary
msgid "**Robo** ブラボー! さあ, 新しい列ができる前にここを離れよう!\n"
"\n"
"女王 *Logisinde* はその間に眠りにつき, あなたたちはこっそりと逃げ出します."
msgstr ""

#: Game.Levels.Logo
msgid "Logo"
msgstr ""

#: Game.Levels.Logo
msgid "あなたは偶然パラレルワールドに迷い込んだ. どうやら帰る方法はないようだ.\n"
"ここに留まり, 適応するしかない.\n"
"\n"
"ここには多くの小さな惑星がある. すべて居住可能で,\n"
"1日に最大7回の夕焼けも楽しめる. しかし, それらの惑星はすべてFormalosophenという\n"
"奇妙な生物に支配されている. 彼らは風変わりな数学的執着を持つ存在だ.\n"
"そして不運なことに, あなたが以前数学者という噂が広まってしまった.\n"
"彼らの尽きることない知識欲を満たさない限り, ここで安らぎを見つけることはできないだろう.\n"
"\n"
"問題は2つある：第一に, Formalosophenたちはどうやら深い数学的理解を全くもっていない.\n"
"第二に, 彼らは数学について「Leansch」という未知の方言でしかコミュニケーションをとらない.\n"
"\n"
"幸い, 小さなスマートエルフRoboもあなたと一緒に宇宙を移動してきた.\n"
"Roboもこの状況で望んでいたような数学の天才ではないが,\n"
"どうやらどこかでLeanschを学んだようだ. これは非常に貴重なことである."
msgstr ""

#: Game.Levels.Implis.L01_Intro
msgid "Intro"
msgstr ""

#: Game.Levels.Implis.L01_Intro
msgid "**作業責任者**: 例えば, ここを見てください:"
msgstr ""

#: Game.Levels.Implis.L01_Intro
msgid "**作業責任者**: 作業員たちはこれが正しく, 私たちが緊急に必要としていると言っています. しかし誰も証明できません. \n"
"\n"
"**あなた**: ちょっと待ってください. これはまさに含意(`\\to`)ですね. `«{B}»`が成り立つと仮定し, `«{A}»`が`«{A}»かつ«{B}»`を意味することを示したいのです. はい, もちろん! 確かに正しいです. \n"
"\n"
"作業責任者は期待の眼差しであなたを見つめています. \n"
"\n"
"**あなた** *(Roboに小声で)*: `tauto`と書いてあげましょうか? \n"
"\n"
"**Robo** *(小声で返答)*: 彼の様子を見ると, それも理解できないでしょう. 証明を丁寧に書いてあげた方がいいです. \n"
"\n"
"**あなた**: でもどうやって? まず『では, `«{A}»`が成り立つと仮定しましょう...』と言いたいのですが. \n"
"\n"
"**Robo**: はい, 良い考えです. 仮定に`h`のような名前を付けて, `intro h`と書いてください."
msgstr ""

#: Game.Levels.Implis.L01_Intro
msgid "**あなた**: わかりました. これで`«{A}»`と`«{B}»`の両方が仮定としてあり, `«{A}» ∧ «{B}»`を示す必要があります. \n"
"\n"
"**Robo**: その通りです. どうすればいいかはもうわかっていますね."
msgstr ""

#: Game.Levels.Implis.L01_Intro
msgid "**作業責任者**: 完璧です! ありがとう! \n"
"\n"
"彼は制御盤に行き, いくつかのボタンを押します. どこかで大きな音とともにベルトコンベアが動き始めます. \n"
"\n"
"**作業責任者**: もう少し時間がありますか?"
msgstr ""

#: Game.Levels.Implis.L02_Revert
msgid "Revert"
msgstr ""

#: Game.Levels.Implis.L02_Revert
msgid "作戦責任者がコンテナから紙の山を取り出します.\n"
"\n"
"**作戦責任者**: ここには本当にたくさん溜まってしまいました. もしあなたが\n"
"もう少し手伝ってくれると本当に助かります.\n"
"\n"
"彼はあなたに一番上の紙を渡します."
msgstr ""

#: Game.Levels.Implis.L02_Revert
msgid "**作戦責任者**: これは同僚からのものです.\n"
"\n"
"**Robo**: あ, これはどこかで読んだことがあります. 待って…そうだ! あの時,\n"
"私がWikipediaをクロールしていた時のことだ: `モーダスポネンスは古代ロジックで既に知られていた推論規則で, 多くの論理的…`\n"
"\n"
"**あなた**: Robo! 求められているのは証明であって歴史的な論文じゃない! それともここで\n"
"`mopo`とかそんなので進められると思ってるの?\n"
"\n"
"**Robo**: はい, いいえ, すみません. `mopo`はありません. 代わりに`revert «{hA}»`を試してみてください."
msgstr ""

#: Game.Levels.Implis.L02_Revert
msgid "**あなた**: なるほど. `revert`は基本的に`intro`の逆ですね.\n"
"\n"
"**Robo**: その通りです. `intro`は証明目標内の含意`«{A}» → «{B}»`から前提を取り出して仮定にします. `revert`は逆に仮定を取り出して含意の前提として証明目標の前に置きます. さあ, もう終わらせてください."
msgstr ""

#: Game.Levels.Implis.L02_Revert
msgid "作戦責任者は喜んであなたの解答を受け取り, 電話に手を伸ばします."
msgstr ""

#: Game.Levels.Implis.L03_Apply
msgid "Apply"
msgstr ""

#: Game.Levels.Implis.L03_Apply
msgid "残念ながら電話での会話はうまくいっていません. 彼はまた電話を切り, 首を振ります. \n"
"\n"
"**作業責任者**: 月の反対側にいる同僚は`revert`を理解していません. あるいは\n"
"少なくともそう装っています. 他にアイデアはありますか? \n"
"\n"
"彼はあなたの証明の下に線を引き, 取り消し線付きの~`revert`~を追加し, \n"
"その紙を再度あなたの前に差し出します."
msgstr ""

#: Game.Levels.Implis.L03_Apply
msgid "**Robo**: おそらく, 与えられた含意を適用する方がより洗練された方法だったでしょう. \n"
"`apply hAB at h`を試してみてください."
msgstr ""

#: Game.Levels.Implis.L03_Apply
msgid "**Robo**: 私は`… at h`と言いました. しかし, 単に`apply hAB`だけでも機能するようです. \n"
"これで, `hAB`を証明目標`B`に適用し, あとは`A`を証明するだけです."
msgstr ""

#: Game.Levels.Implis.L03_Apply
msgid "**あなた**: はい, これも自然に感じます."
msgstr ""

#: Game.Levels.Implis.L03_Apply
msgid "今度は電話での会話がうまくいっているようです."
msgstr ""

#: Game.Levels.Implis.L04_Apply
msgid "Implikation"
msgstr ""

#: Game.Levels.Implis.L04_Apply
msgid "**作戦責任者**: これはまたローカルな問題になりました."
msgstr ""

#: Game.Levels.Implis.L04_Apply
msgid "**あなた**: 含意 $A \\Rightarrow B \\Rightarrow C$ を $A \\Rightarrow C$ に結合する必要がある? \n"
"\n"
"**Robo**: また `intro` から始めてみたら?"
msgstr ""

#: Game.Levels.Implis.L04_Apply
msgid "**作戦責任者**: 私はこの時点でまず `have hB : B` と記録しておくね. \n"
"\n"
"**Robo**: 私の好みから言うと少し余計だな. \n"
"まあ, やってもいいけど. \n"
"\n"
"**Robo** *(あなたへ)*: さあ, やってみて!"
msgstr ""

#: Game.Levels.Implis.L04_Apply
msgid "**Robo**: まずは `B` を証明できるね…"
msgstr ""

#: Game.Levels.Implis.L04_Apply
msgid "**Robo**: …それができたら, `«{hB}» : «{B}»` が仮定として使えるよ."
msgstr ""

#: Game.Levels.Implis.L04_Apply
msgid "**作戦責任者**: 君たちは本当にすごい!"
msgstr ""

#: Game.Levels.Implis.L05_Apply
msgid "Implikation"
msgstr ""

#: Game.Levels.Implis.L05_Apply
msgid "次のページは少し複雑に見えます. 混乱しないように, Roboがすぐにさまざまな含意を図式にまとめます. \n"
"  $$\n"
"  \\begin{CD}\n"
"       A  @>{f}>> B @<{g}<< C    \\\\\n"
"    @V{h}VV    @V{i}VV   @V{j}VV \\\\\n"
"       D  @<{k}<< E @>{l}>> F    \\\\\n"
"    @A{m}AA    @A{n}AA   @V{p}VV \\\\\n"
"       G  @<{q}<< H @>{r}>> I\n"
"  \\end{CD}\n"
"  $$"
msgstr ""

#: Game.Levels.Implis.L05_Apply
msgid "**あなた**: つまり, $A \\Rightarrow I$ の含意の経路を見つけなければならない. \n"
"\n"
"**Robo**: どう始めるか考えてみよう…また `intro` かな?"
msgstr ""

#: Game.Levels.Implis.L05_Apply
msgid "**Robo**: やっぱり `apply` でしょ."
msgstr ""

#: Game.Levels.Implis.L05_Apply
msgid "**Robo**: これは行き止まりみたいだ…"
msgstr ""

#: Game.Levels.Implis.L05_Apply
msgid "**Robo**: これは良くないね."
msgstr ""

#: Game.Levels.Implis.L05_Apply
msgid "**Robo**: うーん, 何か間違ってる…"
msgstr ""

#: Game.Levels.Implis.L05_Apply
msgid "**Robo**: 待って! 道を間違えたよ."
msgstr ""

#: Game.Levels.Implis.L05_Apply
msgid "**Robo**: 本当にそれでいい?"
msgstr ""

#: Game.Levels.Implis.L05_Apply
msgid "**Robo**: えっと…"
msgstr ""

#: Game.Levels.Implis.L05_Apply
msgid "作戦責任者は再び丁寧にお礼を言いました. 彼は再びいくつかのボタンを押し, \n"
"大きなガタンという音と共に, いくつかのコンベアが同時に再起動します."
msgstr ""

#: Game.Levels.Implis.L06_Iff
msgid "Genau dann, wenn"
msgstr ""

#: Game.Levels.Implis.L06_Iff
msgid "**作業責任者**: 私たちは以前, 両方向に動くことができるいくつかのコンベアベルトを持っていました. 最新のマニュアルではこのようなダブルベルトは推奨されていないため, 念のためすべて停止させていました. しかし特定の条件下では安全かもしれませんね? この件についてどう思いますか?"
msgstr ""

#: Game.Levels.Implis.L06_Iff
msgid "**Robo**: `A ↔ B` はもちろんLeanでの $A \\iff B$, つまり「ちょうどそのとき」を表します. \n"
"この命題 `A ↔ B` は2つの部分から成り立ち, `⟨A → B, B → A⟩` と定義されます. \n"
"\n"
"**あなた**: つまりANDの `A ∧ B` とよく似ているんですね? \n"
"\n"
"**Robo**: その通りです. したがって, ここでも `constructor` から始めることができます."
msgstr ""

#: Game.Levels.Implis.L06_Iff
msgid "**あなた**: ああ, そしてその2つの部分はすでに前提条件にありますね."
msgstr ""

#: Game.Levels.Implis.L06_Iff
msgid "**作業責任者**: わかりました, 納得です. \n"
"\n"
"**Robo** *(あなたに向かって)*: ところで, `(h : A ∧ B)` の2つの部分が `h.left` と `h.right` と呼ばれるように, \n"
"`(h : A ↔ B)` の2つの部分は `h.mp` と `h.mpr` と呼ばれます. \n"
"\n"
"**あなた**: つまり `h.mp` は `A → B` ですか? なぜ `mp` なんですか? \n"
"\n"
"**Robo**: `mp` はモーダスポネンスを表します. モーダスポネンスは古代論理学で既に知られていた推論規則で, 多くの論理システムで...あ, いえ, それは聞きたくなかったですよね. 「mpr」の「r」は「reverse」を意味し, 逆方向だからです."
msgstr ""

#: Game.Levels.Implis.L07_Symm
msgid "Genau dann, wenn"
msgstr ""

#: Game.Levels.Implis.L07_Symm
msgid "**作戦責任者**: ここにもこんなものがあります."
msgstr ""

#: Game.Levels.Implis.L07_Symm
msgid "**あなた**: これはただ逆になっただけだ. \n"
"\n"
"**Robo**: それ用のツールを知っています. `symm` または `symm at «{h}»` を使えば, どちらかを反転できます."
msgstr ""

#: Game.Levels.Implis.L07_Symm
msgid "**作戦責任者**: これは簡単でしたね. でも次の問題はもっと難しそうです."
msgstr ""

#: Game.Levels.Implis.L08_Rw
msgid "Genau dann, wenn"
msgstr ""

#: Game.Levels.Implis.L08_Rw
msgid "**作業責任者**: ここで, これについて何か言えることはありますか?"
msgstr ""

#: Game.Levels.Implis.L08_Rw
msgid "**あなた**: $B \\iff A \\iff D \\iff C$, これらはすべて同値ですね…\n"
"\n"
"**Robo**: はい, しかし彼が同値関係を書き換えるのを手伝う必要があります. `rw [h₁]`を使えば, \n"
"`C`を`D`に置き換えることができます."
msgstr ""

#: Game.Levels.Implis.L08_Rw
msgid "**あなた**: 逆方向に書き換えたい場合はどうすればいいですか? \n"
"\n"
"**Robo**: その場合は名前の前に`←`（`\\l`, つまり小文字の「L」）を書きます. つまり`rw [← hₓ]`です."
msgstr ""

#: Game.Levels.Implis.L08_Rw
msgid "**あなた**: ええと, それは間違いでした. \n"
"\n"
"**Robo**: はい, 逆方向の方が良かったですね. しかし, 今のまま進めて, \n"
"`A ↔ A`のような式を得たら, `rfl`で証明できます. \n"
"\n"
"**Robo**: そういえば, `rw`は自動的に`rfl`も試みます. \n"
"つまり, `rfl`を明示的に書く必要はありません."
msgstr ""

#: Game.Levels.Implis.L08_Rw
msgid "**作業責任者**: この調子で進めれば, この山を全部片付けられますね!"
msgstr ""

#: Game.Levels.Implis.L09_Trans
msgid "Genau dann, wenn"
msgstr ""

#: Game.Levels.Implis.L09_Trans
msgid "**あなた**: どうもこの`rw`は, 回りくどく議論しているような気がするんだ. まっすぐに進む方法はないのか, それともここにいるみんなはひねくれているのか?\n"
"\n"
"**Robo**: たぶん`trans`の方がいいと思うよ. これを使えば, $B \\iff A \\iff D \\iff C$という同値の連鎖を一歩ずつ進められる：まず`trans A`で`B \\iff A`の中間ステップを導入し, 次に`trans D`で次のステップに進むんだ."
msgstr ""

#: Game.Levels.Implis.L09_Trans
msgid "**Robo**: どうだい, こっちの方が良かった?\n"
"\n"
"**あなた**: わからない. とにかく先に進めるよ."
msgstr ""

#: Game.Levels.Implis.L10_Iff
msgid "Genau dann wenn"
msgstr ""

#: Game.Levels.Implis.L10_Iff
msgid "**作戦責任者**: これはまた私の理解の遅れた同僚のためです. 彼は`rw`も好きではないようです. それでもできますか?"
msgstr ""

#: Game.Levels.Implis.L10_Iff
msgid "**あなた**: まあ, とりあえず`intro`から始められるかな…\n"
"\n"
"**Robo**: …そしてその後どうなるか見てみましょう!"
msgstr ""

#: Game.Levels.Implis.L10_Iff
msgid "**Robo**: つまり, 含意は`apply`で適用できます…\n"
"\n"
"**あなた**: 知ってるよ! でも`«{h}»`は含意ではなく同値です. \n"
"本当は`rw [← «{h}»]`と言いたいところです. \n"
"\n"
"**Robo**: `«{h}»`の`«{A}» → «{B}»`方向は`«{h}».mp`と呼ばれます. `apply («{h}».mp) at …`で適用できます."
msgstr ""

#: Game.Levels.Implis.L10_Iff
msgid "**Robo**: もちろん, このように始めることもできます."
msgstr ""

#: Game.Levels.Implis.L10_Iff
msgid "**作戦責任者**: はい, 素晴らしい. これでうまくいくはずです. \n"
"\n"
"彼はまた電話しています. \n"
"\n"
"**作戦責任者**: ビンゴ!"
msgstr ""

#: Game.Levels.Implis.L11_Iff
msgid "Genau dann wenn"
msgstr ""

#: Game.Levels.Implis.L11_Iff
msgid "**作戦責任者**: ああ, 次のページもこの同僚のものだ. \n"
"しかし, ここにメモが付いている. 以前この問題の証明をしたことがあるが, \n"
"彼は気に入らなかった. `rw`も`apply`も使わない証明を望んでいたんだ!!\n"
"\n"
"彼は深く息を吸い, ため息をつく. \n"
"\n"
"**作戦責任者**: 彼はいつも自分を実際よりずっと愚かだと装っていると思う. \n"
"でも, 君ならできると思うかい?"
msgstr ""

#: Game.Levels.Implis.L11_Iff
msgid "**あなた**: うーん, 少なくとも含意の部分から始められるかな."
msgstr ""

#: Game.Levels.Implis.L11_Iff
msgid "**Robo**: そうだね, それは`intro`だった."
msgstr ""

#: Game.Levels.Implis.L11_Iff
msgid "**あなた**: えーと, `rw [«{h}»]`や`apply («{h}».mp)`は知ってるけど, 今回はそれを避けたいんだよね. \n"
"\n"
"**Robo**: できることは, `obtain ⟨mp, mpr⟩ := «{h}»`を使って仮定を2つに分けることだよ."
msgstr ""

#: Game.Levels.Implis.L11_Iff
msgid "**Robo**: ここでは`rw [←«{h}»]`か`apply «{h}».mp`を使う必要がある. \n"
"一歩戻って, Goalが`A → B`になるようにした方がいいよ."
msgstr ""

#: Game.Levels.Implis.L11_Iff
msgid "**あなた**: ああ, これで証明目標が仮定の中にあるんだ."
msgstr ""

#: Game.Levels.Implis.L11_Iff
msgid "**作戦責任者**: 完璧, これで十分だ!"
msgstr ""

#: Game.Levels.Implis.L12_ByCases
msgid "by_cases"
msgstr ""

#: Game.Levels.Implis.L12_ByCases
msgid "次の問題に取り組んでいると, 作戦責任者は考え込んだ. \n"
"\n"
"**作戦責任者**: 正直なところ, この書類がどこから来たのか分からない. 私のものではないんだが, \n"
"なんだか面白そうだ."
msgstr ""

#: Game.Levels.Implis.L12_ByCases
msgid "**あなた**: まあ, `A`か`¬A`のどちらかは真になるでしょう. \n"
"\n"
"**Robo**: これは場合分けの典型的なケースだね. `by_cases h : A`を試してみて."
msgstr ""

#: Game.Levels.Implis.L12_ByCases
msgid "**Robo**: ほら, 証明が2つの部分に分かれたでしょう. 最初の部分では`A`が真だと仮定して, \n"
"2番目の部分では`A`が偽だと仮定するんだ."
msgstr ""

#: Game.Levels.Implis.L12_ByCases
msgid "作戦責任者は納得して頷いた."
msgstr ""

#: Game.Levels.Implis.L13_Rw
msgid "Lemmas"
msgstr ""

#: Game.Levels.Implis.L13_Rw
msgid "**作戦責任者**: また同僚のための仕事だ…. 彼はまた`apply`を使わない証明を求めてきた. ここには以前にメモした内容もあるな. そうだ, この補題がある:\n"
"```\n"
"lemma not_not (A : Prop) : ¬¬A ↔ A\n"
"```\n"
"\n"
"**作戦責任者**: これでできるかな?"
msgstr ""

#: Game.Levels.Implis.L13_Rw
msgid "**Robo**: `not_not`のように`↔`や`=`を持つ補題は, `rw [not_not]`という形で使用できます."
msgstr ""

#: Game.Levels.Implis.L13_Rw
msgid "**あなた**: え, なぜこれで`¬¬`の2つが書き換わったの?\n"
"\n"
"**Robo**: `rw`は最初に見つけたものだけを書き換えるので, `¬¬C`が対象です. ただしこれは複数回出現するので, すべて置換されます…\n"
"\n"
"**あなた**: ああ, `¬¬B`は別物だから, もう一度補題を使う必要があるんだね."
msgstr ""

#: Game.Levels.Implis.L13_Rw
msgid "**あなた**: もう終わったの…?\n"
"\n"
"**Robo**: はい, `rw`はその後自動で`rfl`を呼び出そうとしますが, 今回はそれが成功しました."
msgstr ""

#: Game.Levels.Implis.L13_Rw
msgid "この声明の代わりに、しばしば`tauto`や`simp`というtacticも使用可能です。"
msgstr ""

#: Game.Levels.Implis.L14_Summary
msgid "Zusammenfassung"
msgstr ""

#: Game.Levels.Implis.L14_Summary
msgid "**作業責任者**: 本当に助かりました! これが最後の問題です. \n"
"前任者から引き継いだもので, これを解決できれば全てがうまくいくと言っていました. \n"
"しかし私には難しすぎて挑戦する気にもなりませんでした. 試してみますか? \n"
"\n"
"**あなた**: もちろん見せて! Robo, ここまで5分間で学んだ理論的なことをまとめて表示してくれる? \n"
"\n"
"**Robo**: 概要はこちらです：\n"
"\n"
"## 表記/用語\n"
"\n"
"|     | 説明                     |\n"
"|:--- |:------------------------ |\n"
"| `→` | 含意                     |\n"
"| `↔` | 同値/必要十分条件        |\n"
"\n"
"## タクティク\n"
"\n"
"| タクティク       | 例                                                          |\n"
"|:--------------- |:---------------------------------------------------------- |\n"
"| `intro`         | 証明目標の含意の左辺を仮定に取り込む                       |\n"
"| `revert`        | `intro`の逆操作                                            |\n"
"| `apply`         | 含意を証明目標に「逆向き」に適用                           |\n"
"| `apply at`      | 含意を仮定に「順方向」に適用                               |\n"
"| `symm`          | `A ↔ B`を`B ↔ A`に変更                                     |\n"
"| `trans`         | `A ↔ C`を`A ↔ B`と`B ↔ C`に分割                           |\n"
"| `rw [h] `       | 同値`h`を使って証明目標を書き換え                          |\n"
"| `rw [h] at h₁`  | 同値`h`を使って仮定`h₁`を書き換え                          |\n"
"| `by_cases h : P`| `P`と`¬P`で場合分け                                        |                      |"
msgstr ""

#: Game.Levels.Implis.L14_Summary
msgid "Oft kann auch `tauto` diese Art von logischen Ausdrücken lösen."
msgstr ""

#: Game.Levels.Implis.L14_Summary
msgid "Oft kann auch `tauto` diese Art von logischen Ausdrücken lösen."
msgstr ""

#: Game.Levels.Implis.L14_Summary
msgid "**あなた** *(小声)*: これって`→`の定義じゃない? \n"
"\n"
"**Robo** *(小声)*: そう見えるかも. でもLeanでは単なる同値です"
msgstr ""

#: Game.Levels.Implis.L14_Summary
msgid "**Robo**: また`by_cases`が使えるかも"
msgstr ""

#: Game.Levels.Implis.L14_Summary
msgid "**Robo**: 含意はいつも`intro`で攻めるんだ"
msgstr ""

#: Game.Levels.Implis.L14_Summary
msgid "**Robo**: 仮定`h`を`obtain`で分割してみたら?"
msgstr ""

#: Game.Levels.Implis.L14_Summary
msgid "**作業責任者**: 素晴らしい! 本当にありがとう! もうこれ以上引き止めません. \n"
"Quantus星へ向かうんでしょう? \n"
"\n"
"**あなた**: ええ, 多分…\n"
"\n"
"**作業責任者**: 最後にお願いがあります. Quantusの女王様への小包が…\n"
"これも前任者から引き継いだものです. 住所が分からないので郵便局が引き取ってくれません. \n"
"届けてもらえませんか? \n"
"\n"
"**あなた**: もちろん! Robo, ちょっと. \n"
"\n"
"Roboは小包を受け取り, 内部に消えさせた. \n"
"作業責任者は驚いた顔で見つめた. \n"
"\n"
"**Robo**: 心配ない, 私は何も消化しません!"
msgstr ""

#: Game.Levels.Implis
msgid "Implis"
msgstr ""

#: Game.Levels.Implis
msgid "宇宙船に戻り, あなたは近くの惑星へと向かいます. そこにも生命が存在するようです. \n"
"\n"
"**あなた**: Logisinde女王からの課題を`tauto`なしで解けなかった気がする. \n"
"あの課題には含意も含まれていたよね? \n"
"\n"
"**Robo**: 今向かっている惑星「Implis」で, さらに学ぶ機会があるかもしれません. しっかりつかまってください…\n"
"\n"
"そう言うと, Roboは着陸態勢に入りました. \n"
"\n"
"Implisは巨大な露天掘りのようで, 至る所にベルトコンベアが走っていますが, ほとんどが止まっています. \n"
"恥ずかしそうな作業責任者がすでに待ち構えていました. \n"
"\n"
"**作業責任者**: ちょうど良かった! 聞いていますよ. 本物の数学者ですね! \n"
"ここでは真理値を採掘しています. そして非常に注意が必要です. \n"
"ひとつ間違えれば, すべてが崩れます. でも私はとても慎重です. いつも言っています：\n"
"停止してもいい, 崩壊するよりはましだ!"
msgstr ""

#: Game.Levels.Quantus.L01_NonemptyUse
msgid "Natürliche Zahlen"
msgstr ""

#: Game.Levels.Quantus.L01_NonemptyUse
msgid "表面には次のように書かれています."
msgstr ""

#: Game.Levels.Quantus.L01_NonemptyUse
msgid "**あなた**: 自然数が存在することを示せばいいんですか? \n"
"\n"
"**Robo**: その通りです. `use _`を使って任意の自然数を指定してください."
msgstr ""

#: Game.Levels.Quantus.L01_NonemptyUse
msgid "紙を裏返します."
msgstr ""

#: Game.Levels.Quantus.L02_NonemptyObtain
msgid ""
msgstr ""

#: Game.Levels.Quantus.L02_NonemptyObtain
msgid "裏側には次のように書かれています."
msgstr ""

#: Game.Levels.Quantus.L02_NonemptyObtain
msgid "**あなた**: これは何ですか?  `A` は「型」? \n"
"\n"
"**Robo** `A` は単に集合と考えてください…\n"
"\n"
"**あなた** …仮定 `h` によると空ではない? \n"
"\n"
"**Robo** その通り. \n"
"\n"
"**あなた** そして, `A` に要素が存在することを示せばいい? \n"
"\n"
"**Robo** 正解です. \n"
"\n"
"**あなた** それは仮定から直接導かれるのでは? \n"
"\n"
"**Robo** これは `obtain` で「分解」できる仮定です. \n"
"`obtain ⟨a⟩ := h` を試してみてください."
msgstr ""

#: Game.Levels.Quantus.L02_NonemptyObtain
msgid "控えめな拍手が送られます. Formalosophenたちはひそひそ話をしています."
msgstr ""

#: Game.Levels.Quantus.L03_Decide
msgid ""
msgstr ""

#: Game.Levels.Quantus.L03_Decide
msgid "どうやらFormalosophenたちは, あなたたちに提示できる別の問題について合意しようとしているようです. \n"
"しばらくすると, 二つの陣営がはっきりしてきました. \n"
"「偶数」と「奇数」という交互の叫び声が聞こえます. Roboは念のため, 対応する定義を先に示しています：\n"
"\n"
"```\n"
"def Even (n : ℕ) : Prop := ∃ r, n = r + r\n"
"```\n"
"\n"
"彼が`Odd`について話そうとする前に, \n"
"どこからともなく群衆の中から次の紙切れが現れました："
msgstr ""

#: Game.Levels.Quantus.L03_Decide
msgid "**Robo**: 待って! そのためには定義すら必要ないよ! \n"
"\n"
"**あなた**: これはどういうわけか自明だな…\n"
"\n"
"**Robo**: 覚えてる? `decide`は, 真偽を決定する簡単なアルゴリズムがある問題ならすべて解けるんだ. \n"
"具体的な数についての命題は大抵このカテゴリに入るよ!"
msgstr ""

#: Game.Levels.Quantus.L03_Decide
msgid "**あなた**: `decide`は他に何ができるの? \n"
"\n"
"**Robo**: 具体的には, 誰かが`Even 42`が真か偽かを決定する方法について\n"
"実行可能なアルゴリズムを指定しました. `decide`がそのようなアルゴリズムを知っていれば, \n"
"問題を解決できるわけです."
msgstr ""

#: Game.Levels.Quantus.L04_Exists
msgid "Gerade/Ungerade"
msgstr ""

#: Game.Levels.Quantus.L04_Exists
msgid "群衆からの「偶数」「奇数」の叫び声はまだ消えていません. そのため,\n"
"Roboは再度定義を示してくれます\n"
"\n"
"```\n"
"def Even (n : ℕ) : Prop := ∃ r, n = r + r\n"
"```\n"
"\n"
"そして\n"
"\n"
"```\n"
"def Odd (n : ℕ) : Prop := ∃ r, n = 2 * r + 1\n"
"```\n"
"\n"
"これであなたたちはさらに1枚の紙を受け取ります."
msgstr ""

#: Game.Levels.Quantus.L04_Exists
msgid "Das Quadrat einer geraden Zahl ist gerade."
msgstr ""

#: Game.Levels.Quantus.L04_Exists
msgid "**Robo**: 上で見たように, `Even «{n}»`は`r`が存在して`r + r = «{n}»`となることで定義されています.\n"
"この定義を`unfold Even at *`で開くとわかりやすいでしょう.\n"
"\n"
"**あなた**: `decide`では?\n"
"\n"
"**Robo**: `decide`は機能しません. `«{n}»`は具体的な数値ではなく任意の数だからです.\n"
"ここでは実際に作業が必要です!"
msgstr ""

#: Game.Levels.Quantus.L04_Exists
msgid "Robo**: `unfold Even at h`も行うと状況がより明確になります."
msgstr ""

#: Game.Levels.Quantus.L04_Exists
msgid "群衆から困惑したつぶやきが聞こえる.\n"
"\n"
"**あなた**: 待って, なぜ`«{n}» ^ 2 / 2`が自然数になるの?\n"
"\n"
"**Robo**: Leanでのℕ上の除算は常に切り捨てられます. `«{n}» = 1`の場合,\n"
"\n"
"```\n"
"1 ^ 2 = (1 ^ 2) / 2 + (1 ^ 2) / 2\n"
"```\n"
"\n"
"これは計算すると`1 = 1 / 2 + 1 / 2 = 0 + 0`となり, 間違っています!"
msgstr ""

#: Game.Levels.Quantus.L04_Exists
msgid "**あなた**: `«{h}»`から, `s`が存在して`s + s = «{n}»`となることがわかった...\n"
"\n"
"**Robo**: `choose s hs using «{h}»`で実際にこの`s`を導入できます."
msgstr ""

#: Game.Levels.Quantus.L04_Exists
msgid "**あなた**: 今度は`n ^ 2 = r + r`となる適切な数`r`を見つける必要がある?\n"
"\n"
"**Robo**: その通りです. 必要なら`let r := …`でこの数を準備できます."
msgstr ""

#: Game.Levels.Quantus.L04_Exists
msgid "**Robo**: それも可能ですが, 実際に数を考える必要があります."
msgstr ""

#: Game.Levels.Quantus.L04_Exists
msgid "**Robo**: この数は良さそうです! あとは`use r`と言うだけです.\n"
"最初から`use 2 * s^2`と言っても構いません."
msgstr ""

#: Game.Levels.Quantus.L04_Exists
msgid "**あなた**: あ, そして`ring`!\n"
"\n"
"**Robo**: ただし先に`rw`で`n`を`«{s}» + «{s}»`に置き換える必要があります.\n"
"`ring`だけではわからないからです."
msgstr ""

#: Game.Levels.Quantus.L04_Exists
msgid "拍手!"
msgstr ""

#: Game.Levels.Quantus.L05_neg_pow
msgid ""
msgstr ""

#: Game.Levels.Quantus.L05_neg_pow
msgid "また別の質問が届きました. どうやらこれは敵陣営からのもののようです."
msgstr ""

#: Game.Levels.Quantus.L05_neg_pow
msgid "**Robo**: ここは`Odd.neg_pow`を使えば解けると思います."
msgstr ""

#: Game.Levels.Quantus.L05_neg_pow
msgid ""
msgstr ""

#: Game.Levels.Quantus.L05_neg_pow
msgid ""
msgstr ""

#: Game.Levels.Quantus.L05_neg_pow
msgid ""
msgstr ""

#: Game.Levels.Quantus.L06_odd_iff_not_even
msgid ""
msgstr ""

#: Game.Levels.Quantus.L06_odd_iff_not_even
msgid "すぐに次の葉が現れます. \n"
"今回は彼らが妥協点を見つけたようです."
msgstr ""

#: Game.Levels.Quantus.L06_odd_iff_not_even
msgid "**あなた**:  iが偶数か奇数かで場合分けしたいと思います. \n"
"\n"
"**Robo**:  それではやってみてください. 例えば`by_cases h : Even i`で."
msgstr ""

#: Game.Levels.Quantus.L06_odd_iff_not_even
msgid "**Robo**:  `odd_iff_not_even`を使えば, `¬Odd`を`Even`に変換できます."
msgstr ""

#: Game.Levels.Quantus.L06_odd_iff_not_even
msgid "**Robo**:  `odd_iff_not_even`を使えば, `¬Even`を`Odd`に変換できます."
msgstr ""

#: Game.Levels.Quantus.L06_odd_iff_not_even
msgid ""
msgstr ""

#: Game.Levels.Quantus.L06_odd_iff_not_even
msgid ""
msgstr ""

#: Game.Levels.Quantus.L06_odd_iff_not_even
msgid "今回はFormalosophenたちを感心させたようです. 彼らは感心して頷いています. \n"
"\n"
"そしてまた囁き声が聞こえてきます."
msgstr ""

#: Game.Levels.Quantus.L07_Forall
msgid "Für alle"
msgstr ""

#: Game.Levels.Quantus.L07_Forall
msgid "長い混乱の後, 群衆から次の課題があなた方のもとに届きます."
msgstr ""

#: Game.Levels.Quantus.L07_Forall
msgid "**あなた**: この`∀`はきっと「すべてに対して」という意味だ. \n"
"\n"
"**Robo**: そして`\\forall`と書きます. 証明目標の`∀ x, …`は, \n"
"含意のように`intro x`で取り組むことができます."
msgstr ""

#: Game.Levels.Quantus.L07_Forall
msgid "再び認めるように頷く. \n"
"\n"
"再び囁き声."
msgstr ""

#: Game.Levels.Quantus.L08_PushNeg
msgid "PushNeg"
msgstr ""

#: Game.Levels.Quantus.L08_PushNeg
msgid "**Robo**: 待っている間, 量子と否定の関係について少し説明しましょう. すぐに必要になる気がします."
msgstr ""

#: Game.Levels.Quantus.L08_PushNeg
msgid "**あなた**: この`«{P}»`って何? \n"
"\n"
"**Robo**: `«{P}»`は「述語」です. `«{X}»`型のオブジェクトに関する命題です. \n"
"例えば`«{X}»`が自然数の型だとしましょう. \n"
"そして`«{P}» x`は次のような命題かもしれません:\n"
"自然数`x`は偶数である. または: `x`は7つの素因数を持つ. または: `x`は\n"
"Roboのお気に入りの数字である. または…\n"
"\n"
"**あなた**: もう大丈夫, わかった気がする. `«{P}»`は要するに, 要素`x : «{X}»`を取って\n"
"命題を返す写像みたいなものだね. \n"
"\n"
"**Robo**: そう, そんな感じです. \n"
"\n"
"**あなた**: よし. それならこの命題の意味もほぼ明らかだ. \n"
"で, 今からLeanでこれを証明する方法を教えてくれるんだよね? \n"
"\n"
"**Robo**: その通り. 必要なのは`push_neg`です."
msgstr ""

#: Game.Levels.Quantus.L08_PushNeg
msgid "**Robo**: `push_neg`は左から右に作用します. ここではゴールには適用できませんが, \n"
"`«{h}»`には適用できます."
msgstr ""

#: Game.Levels.Quantus.L08_PushNeg
msgid "**Robo**: よくできました. 内部的に`push_neg`は2つの補題を使っています:\n"
"\n"
" - `not_exists (P : X → Prop) : ¬ (∃ x, P x) ↔ ∀ x, (¬ P x)`\n"
" - `not_forall (P : X → Prop) : ¬ (∀ x, P x) ↔ ∃ x, (¬ P x)`\n"
"\n"
"最初の補題が, あなたが今証明した命題です. \n"
"\n"
"**あなた**: なるほど. つまり私はこの命題を, それを使いながら証明したわけだ…\n"
"\n"
"**Robo**: :-) とにかく`push_neg`を覚えておいてください."
msgstr ""

#: Game.Levels.Quantus.L09_PushNeg
msgid "PushNeg"
msgstr ""

#: Game.Levels.Quantus.L09_PushNeg
msgid "長い議論の末, Formalosophenたちはついに以下の問題に合意しました."
msgstr ""

#: Game.Levels.Quantus.L09_PushNeg
msgid "**あなた**: おや. 一番左に`¬`がありますね. 驚きました…"
msgstr ""

#: Game.Levels.Quantus.L09_PushNeg
msgid "**Robo**: この解法は少し難しすぎるようです.\n"
"`Odd`を保持したままにして,\n"
"最終的に`even_iff_not_odd`を使えるようにした方が良いでしょう!"
msgstr ""

#: Game.Levels.Quantus.L09_PushNeg
msgid "**Robo**: この解法は少し難しすぎるようです.\n"
"`Odd`を保持したままにして,\n"
"最終的に`even_iff_not_odd`を使えるようにした方が良いでしょう!"
msgstr ""

#: Game.Levels.Quantus.L09_PushNeg
msgid "**Robo**: ここで`use`を使って数値を指定し, その後おそらく\n"
"補題`even_iff_not_odd`を使う必要があります.\n"
"\n"
"**あなた**: 今すぐ`even_iff_not_odd`を適用できますか?\n"
"\n"
"**Robo**: いいえ, `rw`は量化子内で書き換えできません.\n"
"\n"
"**あなた**: ではどうすればいいのですか?\n"
"\n"
"**Robo**: それは後で教えます, 大勢の前ではやりません.\n"
"今は`use`で適切な数値を指定してから書き換えることをお勧めします."
msgstr ""

#: Game.Levels.Quantus.L09_PushNeg
msgid "**Robo**: 良い選択です! これで`even_iff_not_odd`が使えます."
msgstr ""

#: Game.Levels.Quantus.L09_PushNeg
msgid "**Robo**: 良い選択です! これで`even_iff_not_odd`が使えます."
msgstr ""

#: Game.Levels.Quantus.L09_PushNeg
msgid "**Robo**: 良い選択です! これで`even_iff_not_odd`が使えます."
msgstr ""

#: Game.Levels.Quantus.L09_PushNeg
msgid "Statt diesem Theorem kannst du `push_neg` verwenden."
msgstr ""

#: Game.Levels.Quantus.L09_PushNeg
msgid "Statt diesem Theorem kannst du `push_neg` verwenden."
msgstr ""

#: Game.Levels.Quantus.L09_PushNeg
msgid "Formalosophenたちは大興奮です.\n"
"拍手が収まった後, あなたも一度質問しました.\n"
"\n"
"**あなた** 誰かこの形式ばった宇宙で, 道案内してくれませんか?\n"
"\n"
"**全員** はい, はい.\n"
"\n"
"**あなた** 誰が?\n"
"\n"
"質問がまた具体的すぎました. 気まずい沈黙."
msgstr ""

#: Game.Levels.Quantus.L10_DrinkersParadox
msgid "Drinker's Paradox"
msgstr ""

#: Game.Levels.Quantus.L10_DrinkersParadox
msgid "**あなた**: あなたたちはいつも合唱で話すか, バラバラに話すことしかできないの? \n"
"\n"
"再び長い沈黙が続く. そして突然：\n"
"\n"
"**全員**: 私たちの中には一人, その人が話すと全員が話し出す人物がいる! \n"
"\n"
"あなたは頭を掻く. \n"
"\n"
"**Robo**: 当然だよ. これは有人惑星ならどこでも同じさ! \n"
"\n"
"**あなた**: え? \n"
"\n"
"**Robo**: これは「飲み手のパラドックス」のバージョンだよ! 知らないの? なら手元のライブラリで調べてみたら! *どのバーにも, その人が飲むと全員が飲むという性質を持つ人物がいる*. 正確には：空でないバーならね. \n"
"\n"
"**あなた**: 信じられない. \n"
"\n"
"**Robo**: 私は信じるよ. むしろ, 君が証明できるとさえ思ってる. ほら, 試してみて!"
msgstr ""

#: Game.Levels.Quantus.L10_DrinkersParadox
msgid "**あなた**: つまり, `«{isDrinking}»`はまた述語ってこと…\n"
"`p`が人物なら, `«{isDrinking}» p`は真か偽の命題だ. \n"
"まあそうだよね."
msgstr ""

#: Game.Levels.Quantus.L10_DrinkersParadox
msgid "**あなた**: で, どう始めれば? \n"
"\n"
"**Robo**: 言った通り, 手元のライブラリを見るのが一番だよ. \n"
"正しければ, 場合分けが役立つと思う. `∀ (y : «{People}»), «{isDrinking}» y`が真か偽かでね."
msgstr ""

#: Game.Levels.Quantus.L10_DrinkersParadox
msgid "**Robo**: `by_cases`を見てみて."
msgstr ""

#: Game.Levels.Quantus.L10_DrinkersParadox
msgid "**あなた**: で, 誰を選べば? \n"
"\n"
"**Robo**: 関係ないんじゃない? 仮定`h_nonempty`から誰かいることはわかってる."
msgstr ""

#: Game.Levels.Quantus.L10_DrinkersParadox
msgid "**Robo**: ここは`push_neg at «{h}»`で進められるよ."
msgstr ""

#: Game.Levels.Quantus.L10_DrinkersParadox
msgid "**あなた**: つまり`«{h}»`の後, 飲まない人物が存在する. これを使って命題を自明に真にできる? \n"
"\n"
"**Robo**: 仮定`«{h}»`に`obtain`をどう適用するか見てみて."
msgstr ""

#: Game.Levels.Quantus.L10_DrinkersParadox
msgid "**Robo**: `«{hp}»`と`«{hp'}»`を見て何がわかる?"
msgstr ""

#: Game.Levels.Quantus.L10_DrinkersParadox
msgid "**あなた**: わかった. でももうこの述語論理にはうんざりだ! \n"
"\n"
"**Robo**: なら早く出発しよう! でも聞く前に――この惑星で学んだことのまとめだ. \n"
"\n"
"\n"
"|               | 説明                         |\n"
"|:--------------|:-----------------------------|\n"
"| `∃`           | 存在量化子                   |\n"
"| `∀`           | 全称量化子                   |\n"
"| `Even n`      | `n`は偶数                    |\n"
"| `Odd n`       | `n`は奇数                    |\n"
"\n"
"|       | タクティック                  | 例                                                     |\n"
"|:------|:------------------------------|:-------------------------------------------------------|\n"
"| *13ᶜ* | `rw`                          | 等式で書き換え.                                        |\n"
"| 15    | `ring`                        | `+, -, *, ^`を含む方程式を解く.                        |\n"
"| *4ᵇ*  | `decide`                      | 具体的な数値に関する命題も答えられる.                  |\n"
"| 16    | `unfold`                      | 定義を視覚的に展開する.                                |\n"
"| 17    | `use`                         | Goal中の`∃`に対して具体例を与える.                     |\n"
"| 18    | `choose x hx using h`         | 仮定中の`∃`を分解する.                                 |\n"
"| *8ᵇ*  | `intro`                       | Goal中の`∀`に対処する.                                 |\n"
"| 19    | `push_neg`                    | Goal中の`¬∃`や`¬∀`に対して使用.                        |"
msgstr ""

#: Game.Levels.Quantus
msgid "Quantus"
msgstr ""

#: Game.Levels.Quantus
msgid "Quantusでは, すでに大勢のFormalosophenたちが待ち構えています. \n"
"彼らは皆が一斉に騒ぎ立て, あなたは声をかけることさえ難しい状況です. \n"
"Roboがついに大きなゴングの音を鳴らし, 一時的に静寂をもたらします. \n"
"\n"
"**あなた**: 女王様への手紙を持ってきました. 女王様のもとへ案内していただけませんか? \n"
"\n"
"**全員** *(合唱のように)*: 私たちはもう全員ここにいます! \n"
"\n"
"**あなた**: わかりました. では, どなたが女王様ですか? \n"
"\n"
"すると気まずい沈黙が訪れます. 全員が肩をすくめます. \n"
"\n"
"**あなた**: そもそも女王様はいるんですか? \n"
"\n"
"**全員** *(合唱のように)*: はいはい. 女王様はいます, 女王様はいます. \n"
"\n"
"**Robo** *(あなたに)*: 要約しましょう. 女王は存在するが, 誰もその正体を知らない…\n"
"\n"
"**あなた**: それって矛盾してませんか? \n"
"\n"
"**Robo**: 数学者である君が聞くこと?  いいえ, 矛盾ではありません. これは単なる「純粋な存在命題」です. \n"
"\n"
"あなたは彼が本気で言っているのか少し不安になります. \n"
"\n"
"**あなた**: それなら, 荷物は全住民に渡すことにしましょう. そうすれば女王様にも渡したことになりますから. \n"
"\n"
"**あなた** *(群衆に向かって)*: Implisから皆さんへの荷物です. どうぞ, これが贈り物です. \n"
"\n"
"Roboが群衆に投げると, Formalosophenたちはそれを開封します. \n"
"中には実際, たった1枚の紙きれしか入っていません. \n"
"数分後, それは再びあなたたちの手元に戻ってきます. \n"
"そしてFormalosophenたちは皆, あなたたちがどう対応するか興味津々で見つめています."
msgstr ""

#: Game.Levels.Saturn.L01_Rewrite_equality
msgid ""
msgstr ""

#: Game.Levels.Saturn.L01_Rewrite_equality
msgid "突然, 無線通信が届いた."
msgstr ""

#: Game.Levels.Saturn.L01_Rewrite_equality
msgid "**あなた**: これ, 前に見たことがあるような気がする. \n"
"\n"
"**Robo**: そうだね! これは*Implis*で解いた問題に似ているよ. \n"
"ただ, 今回は「ならば」の代わりに数値の等式があるだけだ! \n"
"でも根本的には何も変わらない. \n"
"`=`と`↔`は`rw`でほぼ同じように扱えるよ."
msgstr ""

#: Game.Levels.Saturn.L01_Rewrite_equality
msgid "**あなた**: つまり`rw [hₓ]`や`rw [← hₓ]`も使える? \n"
"\n"
"**Robo**: 試してみたらどうかな."
msgstr ""

#: Game.Levels.Saturn.L01_Rewrite_equality
msgid "**あなた**: 逆向きの書き換えはどうするんだっけ? \n"
"\n"
"**Robo**: `←`は`\\l`だよ. そして`rw [← hₓ]`と書くんだ"
msgstr ""

#: Game.Levels.Saturn.L01_Rewrite_equality
msgid "👍が返ってきた."
msgstr ""

#: Game.Levels.Saturn.L02_Ring_add_pow_two
msgid ""
msgstr ""

#: Game.Levels.Saturn.L02_Ring_add_pow_two
msgid "次の無線信号は少し違って見える."
msgstr ""

#: Game.Levels.Saturn.L02_Ring_add_pow_two
msgid "**あなた**: ここは匿名の学校数学の場ですか? \n"
"項を並べ替えて計算するだけです. \n"
"`binomi`と返信する必要があるのでしょうか? \n"
"\n"
"**Robo**: いいえ, この宇宙ではこの等式は当然`add_pow_two`と呼ばれます. \n"
"式には最初に「+」, 次に「^2」が来るからです. \n"
"ですから`rw [add_pow_two]`を使うことができます. \n"
"その後, 左辺は右辺と完全に同じに見え, 完了です."
msgstr ""

#: Game.Levels.Saturn.L02_Ring_add_pow_two
msgid "👍が返ってきました. \n"
"\n"
"  **Robo**: ただし, 単に`ring`と言うこともできたでしょう."
msgstr ""

#: Game.Levels.Saturn.L02_Ring_add_pow_two
msgid ""
msgstr ""

#: Game.Levels.Saturn.L03_mul_comm
msgid ""
msgstr ""

#: Game.Levels.Saturn.L03_mul_comm
msgid "また無線信号が届いた."
msgstr ""

#: Game.Levels.Saturn.L03_mul_comm
msgid "**あなた**: あれ, ここでの`P`って何者? \n"
"\n"
"**Robo**: `P`は「多変数多項式」で, 変数は`Fin 2`で番号付けされ, 係数は`ℚ`に属します. \n"
"\n"
"**あなた**: `Fin 2`って何? \n"
"\n"
"**Robo**: 2つの要素を持つ標準集合——$\\{0,1\\}$です. 変数は`X 0`と`X 1`と呼ばれます. \n"
"\n"
"**あなた**: でも実際は関係ないよね? 多項式環は可換だし! \n"
"\n"
"**Robo**: その通りです."
msgstr ""

#: Game.Levels.Saturn.L03_mul_comm
msgid "また👍をもらいました."
msgstr ""

#: Game.Levels.Saturn.L03_mul_comm
msgid ""
msgstr ""

#: Game.Levels.Saturn.L04_mul_assoc
msgid ""
msgstr ""

#: Game.Levels.Saturn.L04_mul_assoc
msgid "また無線信号が届いた."
msgstr ""

#: Game.Levels.Saturn.L04_mul_assoc
msgid "**Robo** ここでは `mul_assoc` を使うといいよ. あるいは *また* `ring` でも…"
msgstr ""

#: Game.Levels.Saturn.L04_mul_assoc
msgid "またまた 👍 だ. \n"
"\n"
"  **あなた**: でも待って, 今回は係数が `ℕ` だったよね! \n"
"  これは環じゃないし, `ℕ` を係数とする多項式も環を成さないよ. \n"
"\n"
"  **Robo**: そうかもね. でも `ring` は半環と呼ばれるものでも使えるんだ. \n"
"\n"
"  **あなた**: へえ…\n"
"\n"
"  匿名のファンカーは, エンドゲームの準備ができているか, \n"
"  それとも彼の惑星を何周か回りたいか知りたがっている. \n"
"\n"
"  「準備OK」とRoboが返信した."
msgstr ""

#: Game.Levels.Saturn.L04_mul_assoc
msgid ""
msgstr ""

#: Game.Levels.Saturn.L04_mul_assoc
msgid ""
msgstr ""

#: Game.Levels.Saturn.L04_mul_assoc
msgid ""
msgstr ""

#: Game.Levels.Saturn.L04_mul_assoc
msgid ""
msgstr ""

#: Game.Levels.Saturn.L04_mul_assoc
msgid ""
msgstr ""

#: Game.Levels.Saturn.L05_Ring
msgid ""
msgstr ""

#: Game.Levels.Saturn.L05_Ring
msgid ""
msgstr ""

#: Game.Levels.Saturn.L05_Ring
msgid "「合格」と匿名の通信士が簡潔に伝えてくる. \n"
"\n"
"  **Robo**: エンジンが十分に回復したようです. \n"
"  さっさと出発しましょう!"
msgstr ""

#: Game.Levels.Saturn
msgid "Saturn"
msgstr ""

#: Game.Levels.Saturn
msgid "実はこの惑星には行きたくなかったのです. \n"
"しかし, あなたは気が散っていました. \n"
"宇宙では注意を怠ってはいけません, 特に不慣れな場所では尚更です. \n"
"もう近づきすぎていて, 重力が強すぎます. 再生可能な推進装置も現在は再生モード中です. \n"
"\n"
"**あなた**: この惑星のオレンジ色の液体は何だ? \n"
"\n"
"**Robo**: 毒々しいですね. あるいは熱いのかも. \n"
"\n"
"**あなた**: あるいは両方か. 本当に着陸したくない! \n"
"\n"
"**Robo**: はいはい, 最善を尽くしています. 見てください, 軌道上にどれだけのゴミが浮かんでいることか! \n"
"今できる最善のことは, 流れに身を任せることです."
msgstr ""

#: Game.Levels.Spinoza.L01_Have
msgid ""
msgstr ""

#: Game.Levels.Spinoza.L01_Have
msgid "**Benedictus**: ほら, 見てください. これはあなたのために準備したものです."
msgstr ""

#: Game.Levels.Spinoza.L01_Have
msgid "**あなた**: まずはこのAND（`∧`）を分解する必要がありそうですね."
msgstr ""

#: Game.Levels.Spinoza.L01_Have
msgid "**あなた**: そして今…\n"
"\n"
"**Benedictus**: …適切な中間結果を準備するべきです. \n"
"\n"
"**Robo**: そうだ! また`have`を使ってみて! 具体的には`have g : ¬ B`!"
msgstr ""

#: Game.Levels.Spinoza.L01_Have
msgid "**あなた**: え? 今これを正しいと仮定しただけ? \n"
"\n"
"**Robo**: いや, 使う前にこれを証明する必要がありますよ."
msgstr ""

#: Game.Levels.Spinoza.L01_Have
msgid "**Robo**: `apply`が役立つはず"
msgstr ""

#: Game.Levels.Spinoza.L01_Have
msgid "**あなた**: そして, 2つの仮定が矛盾する場合はどうするんでしたっけ? \n"
"\n"
"**Robo**: `contradiction`です."
msgstr ""

#: Game.Levels.Spinoza.L01_Have
msgid "**Benedictus**: 良さそうですね!"
msgstr ""

#: Game.Levels.Spinoza.L02_Suffices
msgid "Es reicht!"
msgstr ""

#: Game.Levels.Spinoza.L02_Suffices
msgid "**Benedictus**: もちろん, 最初に主結果を証明してから中間結果を証明することもできたでしょう. この問題で試してみてください, とても似ていますよ."
msgstr ""

#: Game.Levels.Spinoza.L02_Suffices
msgid "**Robo**: 彼の言っていることがわかります!  `have`の代わりに`suffices`を使うこともできます. \n"
"同じように機能しますが, 2つの証明目標が入れ替わります. \n"
"\n"
"**あなた**: つまり, `suffices g : ¬B`の後, まず`g`を使って証明を完了する方法を示し, \n"
"その後で`g`を証明するのですか? \n"
"\n"
"**Robo**: その通りです!"
msgstr ""

#: Game.Levels.Spinoza.L02_Suffices
msgid "**Robo**: ここでは, `«{g}»`が真であると仮定して証明を完了します."
msgstr ""

#: Game.Levels.Spinoza.L02_Suffices
msgid "**Robo**: そしてここで中間結果を証明します."
msgstr ""

#: Game.Levels.Spinoza.L02_Suffices
msgid "**Benedictus**: まさにその通りです. 今後`have`と`suffices`のどちらを使うかは\n"
"完全に好みの問題です. 重要なのは, 遠い目標を小さなステップで達成する方法を知っていることです."
msgstr ""

#: Game.Levels.Spinoza.L03_ByContra
msgid "Widerspruch"
msgstr ""

#: Game.Levels.Spinoza.L03_ByContra
msgid "**Benedictus**: ここに別のバリエーションがあります."
msgstr ""

#: Game.Levels.Spinoza.L03_ByContra
msgid "**Robo**: ゴールにある`¬`は, しばしば矛盾による証明を行いたいことを意味します. \n"
"\n"
"**あなた**: どうやってやるの? `contradiction`を使う? \n"
"\n"
"**Robo**: `by_contra h`で矛盾による証明を開始します. `contradiction`で終了します."
msgstr ""

#: Game.Levels.Spinoza.L03_ByContra
msgid "**Robo**: 今, あなたは仮定`«{h}» : «{A}»`を持っています. これを使って矛盾を導く必要があります. \n"
"\n"
"例えば, `suffices`を使って導きたい矛盾を指定できます. `suffices k : B`のように."
msgstr ""

#: Game.Levels.Spinoza.L03_ByContra
msgid "**あなた**: ああ, 今は単に仮定`«{B}»`と`¬«{B}»`が矛盾していると言えますね."
msgstr ""

#: Game.Levels.Spinoza.L03_ByContra
msgid "**Robo**: そして今, この矛盾に至る中間結果を導く必要があります."
msgstr ""

#: Game.Levels.Spinoza.L03_ByContra
msgid "**Benedictus**: あなたの上達が早いのがわかります!"
msgstr ""

#: Game.Levels.Spinoza.L04_ByContra
msgid ""
msgstr ""

#: Game.Levels.Spinoza.L04_ByContra
msgid "**Benedictus**: 奇数の二乗についての素敵な質問がまだあります.\n"
"しかしその前に, まずこの同値性を証明してください. これはあなた方の間では\n"
"*対偶の同値性*と呼ばれているのではないでしょうか? Leanでは単に\n"
"`not_imp_not`と呼んでいます. こちらの方がずっと分かりやすいですよね?"
msgstr ""

#: Game.Levels.Spinoza.L04_ByContra
msgid ""
msgstr ""

#: Game.Levels.Spinoza.L04_ByContra
msgid "**あなた**: はい, 確かにこれは以前見たことがあります.\n"
"\n"
"**Robo**: もちろん見たことあるでしょう. 数学者はこれを頻繁に使います.\n"
"$A ⇒ B$について何も思いつかない時は, 代わりに$¬B ⇒ ¬A$を示します. 私はこれを\n"
"*対偶*ではなく*背中から胸を突き抜けて目に当てる*と呼びたいところです.\n"
"しかしここではもちろん`not_imp_not`と呼ばれています."
msgstr ""

#: Game.Levels.Spinoza.L04_ByContra
msgid "**Robo**: `constructor`から始めてみてはどうでしょう."
msgstr ""

#: Game.Levels.Spinoza.L04_ByContra
msgid "**Robo**: 再び`suffices g : B`を使って矛盾を導くのが良いでしょう."
msgstr ""

#: Game.Levels.Spinoza.L04_ByContra
msgid "**Robo**: ここでも矛盾による証明を始めるのが良いでしょう."
msgstr ""

#: Game.Levels.Spinoza.L04_ByContra
msgid "**Robo**: `suffices g : ¬ A`が良さそうです."
msgstr ""

#: Game.Levels.Spinoza.L04_ByContra
msgid ""
msgstr ""

#: Game.Levels.Spinoza.L05_Contrapose
msgid "Kontraposition"
msgstr ""

#: Game.Levels.Spinoza.L05_Contrapose
msgid "**Benedictus**: では, 約束していた問題です. `by_contra`を使わずに*直接*証明してみてください."
msgstr ""

#: Game.Levels.Spinoza.L05_Contrapose
msgid "**Robo**: `even_square`の補題に帰着させるのが良いと思います. これは基本的に`Odd (n^2) → Odd n`と言っています.\n"
"対偶を取ると`Even n → Even (n^2)`と同値になります.\n"
"\n"
"**あなた**: その通り. 回り道ですが...待って, 今は`→`が入っていないですね.\n"
"\n"
"**Robo**: `revert`を思い出してください. `revert «{h}»`で仮定`«{h}»`を証明目標の含意に戻せます."
msgstr ""

#: Game.Levels.Spinoza.L05_Contrapose
msgid "**あなた**: これで対偶法の補題が使えますか? 名前は何でしたっけ?\n"
"\n"
"**Robo**: 実際には単に`contrapose`と書けます."
msgstr ""

#: Game.Levels.Spinoza.L05_Contrapose
msgid "**Robo**: 今は`even_iff_not_odd`が役立つかもしれません"
msgstr ""

#: Game.Levels.Spinoza.L05_Contrapose
msgid "**あなた**: 良さそうです. これで既存の補題`even_square`が使えます!"
msgstr ""

#: Game.Levels.Spinoza.L05_Contrapose
msgid "**Benedictus**: 素晴らしい! これで十分に準備が整いましたね."
msgstr ""

#: Game.Levels.Spinoza.L06_Summary
msgid "Contradiction"
msgstr ""

#: Game.Levels.Spinoza.L06_Summary
msgid "**あなた**: でも, 前の問題は矛盾による証明でも同じように解けませんでしたか? \n"
"\n"
"**Benedictus**: もちろんです. ただ, 二度目の矛盾証明は退屈だと思っただけです. \n"
"ですが, この問題をもう一度試してみるのは自由ですよ. \n"
"ほら, 旅のお供にこれを差し上げましょう. \n"
"さあ, 先に進んでください!"
msgstr ""

#: Game.Levels.Spinoza.L06_Summary
msgid "小惑星の重力圏から無事に離脱したら, 再び問題に取り掛かります. \n"
"\n"
"**Robo**: よし, 今回は `by_contra g` から始めよう!"
msgstr ""

#: Game.Levels.Spinoza.L06_Summary
msgid "**Robo**: 今度は `Odd (n ^ 2)` との矛盾を導きたいな."
msgstr ""

#: Game.Levels.Spinoza.L06_Summary
msgid "**Robo**: つまり `suffices d : ¬ Odd (n ^ 2)` だ."
msgstr ""

#: Game.Levels.Spinoza.L06_Summary
msgid "**Robo**: ブラボー! Benedictusが教えてくれたことをまとめましょう. \n"
"\n"
"\n"
"| **戦術**      | **目的**                                              |\n"
"|:----------------|:-------------------------------------------------------|\n"
"| `have`          | 中間結果を仮定する                              |\n"
"| `suffices`      | 中間結果を仮定する                              |\n"
"| `by_contra`     | 矛盾証明を開始する                            |\n"
"| `contradiction` | 矛盾証明を終了する                           |\n"
"| `contrapose`    | 対偶法                                         |\n"
"| `revert`        | `contrapose` を適用する前に有用            |"
msgstr ""

#: Game.Levels.Spinoza
msgid "Spinoza"
msgstr ""

#: Game.Levels.Spinoza
msgid "**Robo**: これはSpinozaだと思う, QEDタイプの非常に珍しい小惑星の一つだ. 急ごう. 少し急がないと, 見逃してしまう. \n"
"\n"
"30分後, あなたたちは着陸した. Spinozaはあまり歓迎的には見えない. 表面全体が細かく赤みがかった砂で覆われている. \n"
"Benedictusと名乗る孤独なFormalosophenが一人, あなたたちを待っていた. \n"
"\n"
"**Benedictus**: 来てくれて嬉しい! 待っていたんだ! \n"
"\n"
"**あなた**: 緊急の質問でもあるの…? \n"
"\n"
"**Benedictus**: いやいや, そんな年齢じゃないよ. でも, Implisやクアントスでどんな目に遭ったかは想像がつく. 他の惑星でも状況はあまり変わらないだろう. でも, 少し準備はできるかもしれない. \n"
"\n"
"**あなた**: ここに留まって少し休めないの? \n"
"\n"
"Benedictusは首を振る. \n"
"\n"
"**Benedictus**: 無理だ. Spinozaは3人の住人を支えられない. そして, あなたたちはすぐにまた出発しなければならない. さもないと道が遠すぎる. 私たちは400年に一度しかこれらの惑星に接近しないんだ."
msgstr ""

#: Game.Levels.Luna.L01_le_rfl
msgid ""
msgstr ""

#: Game.Levels.Luna.L01_le_rfl
msgid "少し圧倒された気分ですが, それでも会話を始めようと試みます.\n"
"\n"
"**あなた**: 大丈夫です, 私たちは混乱を起こさないよう努めています. ここで秩序を保つのはとても大変ですか?\n"
"\n"
"**Lina**: 例えば, `n ≤ n` であることを知っておく必要があります."
msgstr ""

#: Game.Levels.Luna.L01_le_rfl
msgid "**Robo**: `rfl`でどう?"
msgstr ""

#: Game.Levels.Luna.L01_le_rfl
msgid "**Lina**: 認めますが, これは自明な例でした."
msgstr ""

#: Game.Levels.Luna.L01_le_rfl
msgid ""
msgstr ""

#: Game.Levels.Luna.L02_Omega
msgid ""
msgstr ""

#: Game.Levels.Luna.L02_Omega
msgid "**Lina**: 例えば, 整数において`0 < n`や`n < 0`は`n ≠ 0`と同じ意味だということを知っておく必要があります."
msgstr ""

#: Game.Levels.Luna.L02_Omega
msgid "**Ritha** *(小声で)*: `omega`を試してみて!"
msgstr ""

#: Game.Levels.Luna.L02_Omega
msgid "Linaは目を回す. \n"
"\n"
"**Lina**: Rithaは`omega`の大ファンなの. でも`omega`は結構無力なのよ. \n"
"整数の範囲を超えたら, `omega`は何もできなくなっちゃう. \n"
"\n"
"**Ritha**: あなたこそ無力よ! \n"
"\n"
"Rithaは下品な顔をする."
msgstr ""

#: Game.Levels.Luna.L03_Linarith__lt_trichotomy
msgid ""
msgstr ""

#: Game.Levels.Luna.L03_Linarith__lt_trichotomy
msgid "**Lina**: これで試してみて!"
msgstr ""

#: Game.Levels.Luna.L03_Linarith__lt_trichotomy
msgid "通常、証明において`x < y`、`x = y`、`x > y`の3つのケースを区別するために`obtain`と共に使用されます.\n"
"\n"
"```\n"
"obtain h | h | h := lt_trichotomy x y\n"
"```"
msgstr ""

#: Game.Levels.Luna.L03_Linarith__lt_trichotomy
msgid "**あなた**: 場合分け? ?\n"
"\n"
"**Robo**: はい, 試してみてください. 例えば最初に`by_cases h_leq : «{a}» ≤ «{b}»`, 次に`by_cases h_lt : «{a}» < «{b}»`で."
msgstr ""

#: Game.Levels.Luna.L03_Linarith__lt_trichotomy
msgid "**あなた**: で, どうする?\n"
"\n"
"**Lina** (*勝利の表情*): `linarith`だよ!"
msgstr ""

#: Game.Levels.Luna.L03_Linarith__lt_trichotomy
msgid "**Lina**: ところで, 単に`apply lt_trichotomy`と言うこともできたんですよ."
msgstr ""

#: Game.Levels.Luna.L04_Omega2
msgid ""
msgstr ""

#: Game.Levels.Luna.L04_Omega2
msgid "**Lina**:  ここにまだ何かあるわ."
msgstr ""

#: Game.Levels.Luna.L04_Omega2
msgid "Rithaが目で何か合図を送ろうとしているようだ."
msgstr ""

#: Game.Levels.Luna.L04_Omega2
msgid "**Lina**:  はい, わかった, 私のミスね."
msgstr ""

#: Game.Levels.Luna.L05_Linarith2
msgid ""
msgstr ""

#: Game.Levels.Luna.L05_Linarith2
msgid "**Lina:** 同じ質問をもう一度, 今度はℝで!"
msgstr ""

#: Game.Levels.Luna.L05_Linarith2
msgid "**あなた** (*Roboへ*): ここでは`omega`も`linarith`も使えません. \n"
"\n"
"**Robo**: `linarith`に少し手助けが必要なようです. \n"
"まずは標準的に, 2つの含意を`intro`で解きましょう."
msgstr ""

#: Game.Levels.Luna.L05_Linarith2
msgid "**Robo**: そして, 仮定`«{hx}»`をもう少し読みやすくします. \n"
"`push_neg at «{hx}»`を試してみては?"
msgstr ""

#: Game.Levels.Luna.L05_Linarith2
msgid "**Robo**: うーん… `«{hx}» : m ≤ x → n < x`はまだ最適ではありません. \n"
"しかし, `→`の意味はわかっていますね. `imp_iff_or_not`で`rw`してみましょう!"
msgstr ""

#: Game.Levels.Luna.L05_Linarith2
msgid "**Robo**: よし. これで良くなりました. そして, `«{hx}»`を`obtain`で\n"
"2つの部分に分割できます."
msgstr ""

#: Game.Levels.Luna.L05_Linarith2
msgid ""
msgstr ""

#: Game.Levels.Luna.L06_Icc__Icc_insert_succ_right
msgid ""
msgstr ""

#: Game.Levels.Luna.L06_Icc__Icc_insert_succ_right
msgid "**Ritha**: 私もやってみていい? ほら."
msgstr ""

#: Game.Levels.Luna.L06_Icc__Icc_insert_succ_right
msgid "(version for ℤ)"
msgstr ""

#: Game.Levels.Luna.L06_Icc__Icc_insert_succ_right
msgid "**あなた**: Iccって何? \n"
"\n"
"**Ritha**: 左閉右閉の**閉**区間よ. \n"
"\n"
"**Robo**: ℕでは`Icc a b`を[a, b]や$\\{a, a+1,\\dots,b\\}$と書くでしょう. \n"
"示すべきは：\n"
"$$\n"
"[a, b] ∪ \\{ b + 1 \\} = [a, b + 1]\n"
"$$"
msgstr ""

#: Game.Levels.Luna.L06_Icc__Icc_insert_succ_right
msgid "**Robo:** 集合の等式は`ext`で."
msgstr ""

#: Game.Levels.Luna.L06_Icc__Icc_insert_succ_right
msgid "**Robo:** すぐに`simp`も使いましょう."
msgstr ""

#: Game.Levels.Luna.L06_Icc__Icc_insert_succ_right
msgid "Rithaがまた何か書いている."
msgstr ""

#: Game.Levels.Luna.L06_Icc__Icc_insert_succ_right
msgid "(version for ℕ)"
msgstr ""

#: Game.Levels.Luna.L06_Icc__Icc_insert_succ_right
msgid "(version for ℕ)"
msgstr ""

#: Game.Levels.Luna.L06_Icc__Icc_insert_succ_right
msgid "(version for ℤ)"
msgstr ""

#: Game.Levels.Luna.L06_Icc__Icc_insert_succ_right
msgid "(version for ℕ)"
msgstr ""

#: Game.Levels.Luna.L06_Icc__Icc_insert_succ_right
msgid "(version for ℤ)"
msgstr ""

#: Game.Levels.Luna.L06_Icc__Icc_insert_succ_right
msgid "(version for ℕ)"
msgstr ""

#: Game.Levels.Luna.L06_Icc__Icc_insert_succ_right
msgid "(version for ℤ)"
msgstr ""

#: Game.Levels.Luna.L06_Icc__Icc_insert_succ_right
msgid ""
msgstr ""

#: Game.Levels.Luna.L07_Linarith2
msgid ""
msgstr ""

#: Game.Levels.Luna.L07_Linarith2
msgid "**Lina**: `omega`はもう十分, 今度は私の番よ."
msgstr ""

#: Game.Levels.Luna.L07_Linarith2
msgid "**あなた**: これはまず縦に書き直す必要があるな. 与えられた条件は:\n"
"\n"
"$$\n"
"\\begin{aligned}\n"
"\\tfrac{35}{11}\\cdot y &\\le -\\tfrac{22}{21}\\cdot x + \\tfrac{35}{2}  \\\\\n"
"\\tfrac{8}{9} \\cdot y &\\le x + \\tfrac{17}{8}\n"
"\\end{aligned}\n"
"$$\n"
"\n"
"そして証明すべきは:\n"
"$$\n"
"y ≤ \\tfrac{34}{7}\n"
"$$\n"
"\n"
"Robo? ? \n"
"\n"
"Linaがニヤリと笑う."
msgstr ""

#: Game.Levels.Luna.L07_Linarith2
msgid "**あなた**: 悪くないね!"
msgstr ""

#: Game.Levels.Luna.L08_Omega3
msgid ""
msgstr ""

#: Game.Levels.Luna.L08_Omega3
msgid "**Ritha**:  今度は私の番よ!"
msgstr ""

#: Game.Levels.Luna.L08_Omega3
msgid "**Ritha**:  絶対に`simp at «{h'}»`を試してみて."
msgstr ""

#: Game.Levels.Luna.L08_Omega3
msgid ""
msgstr ""

#: Game.Levels.Luna.L09_lt_trichotomy2
msgid ""
msgstr ""

#: Game.Levels.Luna.L09_lt_trichotomy2
msgid "**Lina**: 今度は私の番ね."
msgstr ""

#: Game.Levels.Luna.L09_lt_trichotomy2
msgid "**あなた**:\n"
"さて, ここでどの`b`を使うべきかはかなり明白ですね. \n"
"\n"
"**Robo**: そんなに明白なら, まず`use …`から始めてみたらどうですか. \n"
"その後, `lt_trichotomy`が役に立つでしょう. 例えばこうです：\n"
"```\n"
"obtain h | h | h := lt_trichotomy a c\n"
"```"
msgstr ""

#: Game.Levels.Luna.L09_lt_trichotomy2
msgid "**Lina**: よくできました! 残念ながらもう出発しなければならないのですね. \n"
"  でも, もっと長くいると私たちの生活リズムが完全に乱れてしまいますから."
msgstr ""

#: Game.Levels.Luna.L10_Icc_subset_Icc_iff
msgid ""
msgstr ""

#: Game.Levels.Luna.L10_Icc_subset_Icc_iff
msgid "**Ritha**（*Linaに向かって*）：お願い, 私にも一つ質問させて……\n"
"\n"
"**Lina**：わかった, 一つだけね……でもまた`omega`はダメよ! \n"
"\n"
"Rithaは大きな目をして, Linaに懇願するように見つめる. \n"
"\n"
"**Lina**：どうしても*絶対に*必要なのなら. でも急いで! もう本当に時間がないの!"
msgstr ""

#: Game.Levels.Luna.L10_Icc_subset_Icc_iff
msgid ""
msgstr ""

#: Game.Levels.Luna.L10_Icc_subset_Icc_iff
msgid "**Robo**: ここではまた`subset_iff`が役立つかもしれません. どうしてもわからなかったら, `simp`を試してみて."
msgstr ""

#: Game.Levels.Luna.L10_Icc_subset_Icc_iff
msgid "**Robo**: 仮定`«{h}»`を何らかの形で利用する必要があります. \n"
"`«{h}»`を不等式`a₁ ≤ b₁`や`a₁ ≤ a₁`に適用してみてはどうでしょう! \n"
"（不等式`a₁ ≤ a₁`は`have`を使って表現するのがベストです）"
msgstr ""

#: Game.Levels.Luna.L10_Icc_subset_Icc_iff
msgid ""
msgstr ""

#: Game.Levels.Luna
msgid "Luna"
msgstr ""

#: Game.Levels.Luna
msgid "Roboは小さな月を発見し, そこへ向かっています. \n"
"表面はとても滑らかですが, 一部に小さな開口部があり, 階段が内部へ続いています. \n"
"着陸して好奇心から降りていくと, 今まで見た中で最も整頓された住居にたどり着きます. \n"
"小さな女の子が皆を迎えます. \n"
"\n"
"**Lina**: 私はLina, Lunaの唯一の住人よ. \n"
"\n"
"彼女はRoboを見ます. \n"
"\n"
"**Lina**: まあ, 実際はここには2人いるんだけど…\n"
"\n"
"振り返って何か叫ぶと, スマートエルフがやってきます. \n"
"\n"
"**Lina**: これはRithaよ! \n"
"\n"
"Roboは明らかに彼女を可愛いと思っています. \n"
"\n"
"**Lina**: でも, こんなところで散らかって立たないで! 靴とヘルメットはあそこに片付けて, \n"
"それから訪問者用のマークされた場所に立ってね. じゃないと, 私が混乱しちゃうわ."
msgstr ""

#: Game.Levels.Babylon.L01_Sum_Simp_Card
msgid ""
msgstr ""

#: Game.Levels.Babylon.L01_Sum_Simp_Card
msgid "**Babylonier人**: 各塔には碑文があります. そこに, なぜその塔が建てられたのかを詳しく読むことができます. 例えば, ここにあります."
msgstr ""

#: Game.Levels.Babylon.L01_Sum_Simp_Card
msgid "**あなた**: ああ, これは本当にたくさんの新しいことだ…見てみよう…\n"
"\n"
"これは $( \\sum_{i\\in I} 1)$ が…に等しいように見えます. \n"
"\n"
"**Robo**: …$I$の要素の数, つまり$I$のカーディナリティです. \n"
"\n"
"**Babylonier人**: そして, これを証明できますか? \n"
"\n"
"**Robo** *(あなたに向かって)*: 最初に`simp`を試してみることをお勧めします. \n"
"これは本当に強力な戦術で, 多くの項を単純化します."
msgstr ""

#: Game.Levels.Babylon.L01_Sum_Simp_Card
msgid "**Babylonier人**: よくできました, これで合っています!"
msgstr ""

#: Game.Levels.Babylon.L02_Card2
msgid ""
msgstr ""

#: Game.Levels.Babylon.L02_Card2
msgid "一緒に次の塔を見てみましょう."
msgstr ""

#: Game.Levels.Babylon.L02_Card2
msgid "**あなた**: また`simp`を使う?"
msgstr ""

#: Game.Levels.Babylon.L03_sum_congr
msgid ""
msgstr ""

#: Game.Levels.Babylon.L03_sum_congr
msgid "次に, 長い間何も行われていないように見える空き建築現場に到着します. \n"
"看板には次のように書かれています："
msgstr ""

#: Game.Levels.Babylon.L03_sum_congr
msgid "**あなた**: この仮定は$I \\subseteq \\{-1,0,1\\}$の複雑なバリエーションのように見えます. \n"
"どうせ大きな合計にはならないでしょう. \n"
"\n"
"**Robo**: いいえ. しかし, 指定された結果を得るためには中間ステップが必要です. \n"
"`trans ∑ i ∈ I, 0`と書くことを提案します. 合計記号は`\\sum`と書きます."
msgstr ""

#: Game.Levels.Babylon.L03_sum_congr
msgid "**Robo**: その通りです. これで`apply sum_congr`と書くことができます\n"
"- 特に, 同じインデックス集合に対して合計が行われ, 合計される式も一致する場合, 2つの合計は等しくなります."
msgstr ""

#: Game.Levels.Babylon.L03_sum_congr
msgid ""
msgstr ""

#: Game.Levels.Babylon.L04_sum_subset
msgid ""
msgstr ""

#: Game.Levels.Babylon.L04_sum_subset
msgid "あなたは塔から塔へとさらに歩き続けます. ついに, 奇妙に感じる塔の前で立ち止まりました. 一周してみると, その理由がわかります：\n"
"  入口がありません. しかし, 次のような碑文が刻まれた床板を見つけました."
msgstr ""

#: Game.Levels.Babylon.L04_sum_subset
msgid "**あなた**: ゆっくりいこう. 示すべきは：\n"
"\n"
"$$\n"
"\\sum_{i=0}^{n} (i^3 - 3 i^2 + 2 i)  = \\sum_{i=3}^{n} (i^3 - 3 i^2 + 2i)\n"
"$$\n"
"\n"
"おそらく, 和の中の式は最初の3つのiの値に対して単に0になる…そう, その通りだ. \n"
"では, これをどう表現すればいい? \n"
"\n"
"**Robo**: `sum_subset`を使うといいよ：`I₁ ⊆ I₂`で, \n"
"和の中の式が`I₁`の要素で`I₂`に含まれないすべての要素に対して0になるなら, \n"
"`I₁`の和は`I₂`の和に等しい."
msgstr ""

#: Game.Levels.Babylon.L04_sum_subset
msgid "**Robo**: いや, それは逆に見えるね."
msgstr ""

#: Game.Levels.Babylon.L04_sum_subset
msgid "**Robo**: まず`symm`で等式の両辺を入れ替えて."
msgstr ""

#: Game.Levels.Babylon.L04_sum_subset
msgid "**Robo**: いいね. そして`apply sum_subset`."
msgstr ""

#: Game.Levels.Babylon.L04_sum_subset
msgid "**Robo**: ここでは`Icc_subset_Icc_iff`が役立つはずだよ."
msgstr ""

#: Game.Levels.Babylon.L04_sum_subset
msgid "**Robo**: 素晴らしい! あとはさっき言ったことを示すだけ：\n"
"和の下の式は最初の3つのインデックスで0になる."
msgstr ""

#: Game.Levels.Babylon.L04_sum_subset
msgid "**Robo**: まずすべての仮定を導入して, \n"
"```\n"
"i ^ 3 - 3 * i ^ 2 + 2 * i = 0\n"
"```\n"
"が証明目標になるまで進めることを提案するよ."
msgstr ""

#: Game.Levels.Babylon.L04_sum_subset
msgid "**Robo**: 仮定から$«{i}»=0$または$«{i}»=1$または$«{i}»=2$が導かれるはず. \n"
"おそらく`have`で明示的に表現してみて."
msgstr ""

#: Game.Levels.Babylon.L04_sum_subset
msgid "**Robo**: 仮定から$«{i}»=0$または$«{i}»=1$または$«{i}»=2$が導かれるはず. \n"
"`have`で明示的に表現してみて."
msgstr ""

#: Game.Levels.Babylon.L04_sum_subset
msgid "**Robo**: 何らかの`simp`と`omega`の組み合わせで解決するはず. \n"
"Lunaでもうまくいったよ."
msgstr ""

#: Game.Levels.Babylon.L04_sum_subset
msgid "**Robo**: 仮定«{h}»を`obtain h | h | h  := «{h}»`で3つのケースに分けられるよ."
msgstr ""

#: Game.Levels.Babylon.L04_sum_subset
msgid ""
msgstr ""

#: Game.Levels.Babylon.L05_sum_subset2
msgid ""
msgstr ""

#: Game.Levels.Babylon.L05_sum_subset2
msgid ""
msgstr ""

#: Game.Levels.Babylon.L05_sum_subset2
msgid "**あなた**: ここで示すべきことは\n"
"$$\n"
"\\sum_{i \\in I} \\left( (-1)^i + 1 \\right)\n"
"$$\n"
"がI内の偶数の数の2倍に等しいということですよね? \n"
"\n"
"**Robo**: その通りです. \n"
"\n"
"**あなた**: そしてそれは...和の中の式が奇数iでは0になり, \n"
"偶数iでは2になるからです. うーん...\n"
"\n"
"**Robo**: `trans`を使って中間ステップを作りましょう. まず和を偶数インデックスの集合に制限します：\n"
"```\n"
"∑ i ∈ { i ∈ I | Even i}, ((-1)^i + 1)\n"
"```\n"
"その後, おそらく\n"
"```\n"
"∑ i ∈ { i ∈ I | Even i}, 2\n"
"```\n"
"を中間ステップとして使いたいのでしょう."
msgstr ""

#: Game.Levels.Babylon.L05_sum_subset2
msgid "**Robo**: これは何か間違っているようです...\n"
"`sum_subset`を逆に適用した方が良いかもしれません. \n"
"またはこのステップの前に`symm`で等式を反転させてください."
msgstr ""

#: Game.Levels.Babylon.L05_sum_subset2
msgid "**Robo**: これについては以前`Even.neg_pow`と`Odd.neg_pow`を見たことがありますね."
msgstr ""

#: Game.Levels.Babylon.L05_sum_subset2
msgid "**Robo**: 良さそうです. これで`sum_congr`を使える段階です."
msgstr ""

#: Game.Levels.Babylon.L05_sum_subset2
msgid "**Robo**: もう一度`simp`を試してみてください."
msgstr ""

#: Game.Levels.Babylon.L05_sum_subset2
msgid "**Babylonier人**: よくできました."
msgstr ""

#: Game.Levels.Babylon.L06_Induction_sum_insert__arithmetic_sum
msgid ""
msgstr ""

#: Game.Levels.Babylon.L06_Induction_sum_insert__arithmetic_sum
msgid "**Babylon人**: さあ, 私たちの最も美しい塔の一つをお見せしましょう! \n"
"\n"
"道は険しい山道を登っていきます. 山頂で待つ塔は, 実に壮大なものです. \n"
"\n"
"**Robo**: これは有名な『Babylonのガウス塔』に違いありません! \n"
"それについて一度読んだことがあります. \n"
"\n"
"**Babylon人**: その通り. ガウスはBabylon人でした!"
msgstr ""

#: Game.Levels.Babylon.L06_Induction_sum_insert__arithmetic_sum
msgid ""
msgstr ""

#: Game.Levels.Babylon.L06_Induction_sum_insert__arithmetic_sum
msgid "**あなた**: この和は以前見たことがあります. \n"
"$$\n"
"\\sum_{i = 0}^n i = \\tfrac{1}{2} \\cdot n \\cdot (n + 1)\n"
"$$\n"
"\n"
"ガウス少年がとても簡単な証明をしたという話ではありませんでしたか? \n"
"\n"
"**Robo**: 歴史の話はわかりません. 私は単に`n`についての帰納法を使うでしょう. \n"
"それはLeanでは`induction n with d hd`です! \n"
"\n"
"**あなた**: なぜ`with …`が必要なのですか? \n"
"\n"
"**Robo**: もちろんこの追加はオプションです. \n"
"これで帰納変数(`d`)と帰納仮説(`hd`)の名前を指定できます."
msgstr ""

#: Game.Levels.Babylon.L06_Induction_sum_insert__arithmetic_sum
msgid "**あなた**: まず帰納法の基底ケース…\n"
"\n"
"**Robo**: これはしばしば`simp`で簡略化できます!"
msgstr ""

#: Game.Levels.Babylon.L06_Induction_sum_insert__arithmetic_sum
msgid "**Robo**: 今, 和を取る区間$[0, «{d}»+1]$を$[0,«{d}»]$と$«{d}»+1$に分割したいですね. \n"
"そのためには, 以前見た`insert_Icc_eq_Icc_add_one_right`という補題が使えます."
msgstr ""

#: Game.Levels.Babylon.L06_Induction_sum_insert__arithmetic_sum
msgid "**Robo**: そうです! そして今, `sum_insert`が和をあなたが望むように正確に分割します：\n"
"$[0,«{d}»]$の和と, $«{d}»+1$の追加項です. \n"
"試してみてください：`rw [sum_insert]`"
msgstr ""

#: Game.Levels.Babylon.L06_Induction_sum_insert__arithmetic_sum
msgid "**あなた**: そして今, 帰納仮説をどのように適用すればよいですか? \n"
"\n"
"**Robo**: 他の仮定と同じように`rw`で使えます."
msgstr ""

#: Game.Levels.Babylon.L06_Induction_sum_insert__arithmetic_sum
msgid "**あなた**: 残りは単なる計算のはずです. \n"
"\n"
"**Robo**: その通りです. `simp`と`ring`の組み合わせで解決できるはずです."
msgstr ""

#: Game.Levels.Babylon.L06_Induction_sum_insert__arithmetic_sum
msgid ""
msgstr ""

#: Game.Levels.Babylon.L06_Induction_sum_insert__arithmetic_sum
msgid ""
msgstr ""

#: Game.Levels.Babylon.L07_Induction2_sum_insert2
msgid ""
msgstr ""

#: Game.Levels.Babylon.L07_Induction2_sum_insert2
msgid "ガウスの塔のすぐ隣に, 再び空き地があります.  今回は看板に次のように書かれています："
msgstr ""

#: Game.Levels.Babylon.L07_Induction2_sum_insert2
msgid "**あなた**:  $\\sum_{i=-n}^«{n}» i = 0$ – はい, これは正しいようです. \n"
"\n"
"**Robo**: 先ほどのガウス和と同じように証明できるはずです…\n"
"ただし, `insert_Icc_eq_Icc_add_one_right` の後には\n"
"`insert_Icc_eq_Icc_sub_one_left` も必要になるでしょう."
msgstr ""

#: Game.Levels.Babylon.L07_Induction2_sum_insert2
msgid "**Robo**: その通り, 今度も `rw [sum_insert]` を使ってください."
msgstr ""

#: Game.Levels.Babylon.L07_Induction2_sum_insert2
msgid "**Robo**: 次は `-1 + -«{d}»` を `-«{d}» - 1` と書き換える必要があります. \n"
"おそらく, この等式を `have` で表現するのが最も簡単でしょう. \n"
"ℤ における等式であることを明確にする必要があります. \n"
"例えば次のように：\n"
"```\n"
"have : -1 + (-d : ℤ)  = -d - 1\n"
"```"
msgstr ""

#: Game.Levels.Babylon.L07_Induction2_sum_insert2
msgid ""
msgstr ""

#: Game.Levels.Babylon.L08_Induction3_sub_insert3
msgid ""
msgstr ""

#: Game.Levels.Babylon.L08_Induction3_sub_insert3
msgid "純粋な好奇心から, あなたは別の隣の塔をさらに詳しく見ています."
msgstr ""

#: Game.Levels.Babylon.L08_Induction3_sub_insert3
msgid "**あなた**: ここでは奇数のみの和ですね. \n"
"$$\n"
"\\sum_{i = 0}^n (2i + 1) = n^2\n"
"$$\n"
"\n"
"**Robo**: 前回と全く同じように解けますよ."
msgstr ""

#: Game.Levels.Babylon.L08_Induction3_sub_insert3
msgid "**Babylonier人**: どうですか?  ここは気に入りましたか? \n"
"\n"
"  **Robo**: はい, とても. ここに築かれたものは全て本当に印象的です. \n"
"  しかし, これ以上あなた方の時間を奪いたくありません. \n"
"\n"
"  **あなた**: そろそろ出発した方がいいと思います. \n"
"\n"
"  あなた方は別れの挨拶をし, 宇宙船へと戻る道を歩き始めます."
msgstr ""

#: Game.Levels.Babylon.L09_Boss
msgid ""
msgstr ""

#: Game.Levels.Babylon.L09_Boss
msgid "まだ遠くまで進んでいないところで, 塔の後ろから突然特に大きなBabylonier人が現れ, \n"
"道を塞ぎ, 険しい顔で睨みつけながら, 次の等式の証明を低い声で要求してきます."
msgstr ""

#: Game.Levels.Babylon.L09_Boss
msgid "**あなた**: まあ, きっとうまくいくでしょう…"
msgstr ""

#: Game.Levels.Babylon.L09_Boss
msgid "**Robo**: `arithmetic_sum`は既に証明済みだということを覚えておいてください."
msgstr ""

#: Game.Levels.Babylon.L09_Boss
msgid "Babylonier人は長い間考え込み, あなたは彼が決して攻撃的ではなかったこと, \n"
"ただ非常に低い声を持っていただけだと感じ始めます. \n"
"\n"
"小さな地震と共に彼は座り込み, 感謝の意を込めて手を振ります."
msgstr ""

#: Game.Levels.Babylon
msgid "Babylon"
msgstr ""

#: Game.Levels.Babylon
msgid "無数の石板が奇妙なほど高い塔に積み上げられた惑星に到着しました. この風景全体は大きなパズルのようで, 各石板は下にある石板の上に注意深く積まれています. あまりに高い塔もあり, 頂上は見えません. すぐにこの惑星の最初の住人に出会います. \n"
"\n"
"**Babylonier人**: *Babylon*へようこそ! \n"
"\n"
"**あなた**: ああ…\n"
"\n"
"不安な気持ちがよぎります. \n"
"\n"
"**あなた**: これらの塔は本当に安定しているんですか? \n"
"\n"
"**Babylonier人**: 100％! \n"
"\n"
"**あなた**: どうやってこれらの傑作を建てるんですか? \n"
"\n"
"**Babylonier人**: 簡単だよ! 石を一つずつ積み上げるだけ."
msgstr ""

#: Game.Levels.Cantor.L01_CantorPowerset
msgid "Cantor's Diagonalargument"
msgstr ""

#: Game.Levels.Cantor.L01_CantorPowerset
msgid "**Cantor**: … 我々は集合`A`からその冪集合への写像`f`を考え, \n"
"そして`A`の要素で`f`による像に含まれないもの全ての集合を…\n"
"\n"
"おや! 観客がいる. いや, *二人*の観客だ! 聞け, 見よ, 驚くがいい. \n"
"\n"
"彼はシルクハットから紙片を取り出し, ツバメのように折りたたみ, \n"
"あなた方へと飛ばしてくる. \n"
"\n"
"**Cantor**: 二人の観客がいるのなら, 少し参加してもらおうじゃないか?"
msgstr ""

#: Game.Levels.Cantor.L01_CantorPowerset
msgid ""
msgstr ""

#: Game.Levels.Cantor.L01_CantorPowerset
msgid "**あなた**: つまり`Set A`は`A`の冪集合なの? \n"
"\n"
"**Robo**: まあそういうことだね. `A`の全ての部分集合の集合, より正確には型だ. \n"
"\n"
"**あなた**: そして私が示すべきは…なるほど. おそらく背理法かな? \n"
"\n"
"**Robo**: おそらくね."
msgstr ""

#: Game.Levels.Cantor.L01_CantorPowerset
msgid "**Cantor**: よしよし! さあ`«{h}»`をきれいに分解しよう…"
msgstr ""

#: Game.Levels.Cantor.L01_CantorPowerset
msgid "**Robo: …いつものように`obtain`でね"
msgstr ""

#: Game.Levels.Cantor.L01_CantorPowerset
msgid "**あなた**: 今度は`«{a}» ∈ «{f}» «{a}»`について場合分けする?"
msgstr ""

#: Game.Levels.Cantor.L01_CantorPowerset
msgid "**Robo**: `by_cases h₁ : «{a}» ∈ «{f}» «{a}»`だね"
msgstr ""

#: Game.Levels.Cantor.L01_CantorPowerset
msgid "Cantorは手を擦り合わせる. \n"
"\n"
"**Cantor**: いい調子だ!"
msgstr ""

#: Game.Levels.Cantor.L01_CantorPowerset
msgid "**Cantor**: 良い考えだ! ほぼ正解! \n"
"だが元の仮定`«{h₁}» : «{a}» ∈ «{f}» «{a}»`がもう一度必要になるだろう. \n"
"\n"
"**Robo**: 了解, 戻って`have`で続けよう. \n"
"または`suffices : «{a}» ∉ «{f}» «{a}»`で!"
msgstr ""

#: Game.Levels.Cantor.L01_CantorPowerset
msgid "Cantorは手を叩いて喜ぶ. \n"
"魔法のように紙片は彼のもとへ飛んで帰っていった."
msgstr ""

#: Game.Levels.Cantor.L02_CantorPowerset
msgid "Cantor's Diagonalargument"
msgstr ""

#: Game.Levels.Cantor.L02_CantorPowerset
msgid "**Cantor**: 注意してください, この議論は実はさらに続くのです! \n"
"\n"
"彼はシルクハットに手を伸ばし, あらゆるものを取り出します. \n"
"古い歯ブラシ, トランプ, 白いウサギ……\n"
"ついに皺くちゃのメモ用紙が見つかりました. \n"
"\n"
"**Cantor**: ここに私のノートがあった! ほら! 私の有名な対角線論法だ! \n"
"\n"
"彼は紙を広げ, 慎重に一番上の行を引き裂き, \n"
"あなたの方へと舞い降りさせます. \n"
"そして舞台の端から興味津々で覗き込み, あなたの反応を見守ります."
msgstr ""

#: Game.Levels.Cantor.L02_CantorPowerset
msgid "**あなた**: これは前に見たことがあります! \n"
"要するに「べき集合は常に元の集合より大きい」ということですね. \n"
"背理法だったと思います. \n"
"\n"
"**Robo**: はい, ですが`push_neg`と`intro f`から始めるのが良いでしょう."
msgstr ""

#: Game.Levels.Cantor.L02_CantorPowerset
msgid "**Cantor**: さて, どう思いますか? おそらく`f`によってカバーされない集合があるのではないでしょうか?"
msgstr ""

#: Game.Levels.Cantor.L02_CantorPowerset
msgid "**Robo**: 先ほどの集合を試してみてください! \n"
"まず`let s := { a | a ∉ «{f}» a }`で導入できます."
msgstr ""

#: Game.Levels.Cantor.L02_CantorPowerset
msgid "**Robo**: 素晴らしい! \n"
"これで例えば`specialize «{hf}» «{s}»`と続けられます. \n"
"後で`simp`を使うときは`simp [«{s}»]`とすれば, `simp`が定義を見通してくれます."
msgstr ""

#: Game.Levels.Cantor.L02_CantorPowerset
msgid "Cantorは片足からもう片足へと飛び跳ねています."
msgstr ""

#: Game.Levels.Cantor.L02_CantorPowerset
msgid "**Cantor**: そうだ! \n"
"\n"
"**あなた**: Robo, 今こそ先ほどの結果を使えるのでは? \n"
"\n"
"**Robo**: すみません, 全てが早すぎました! 保存するのを忘れたようです."
msgstr ""

#: Game.Levels.Cantor.L03_IsFixedPt_abs
msgid ""
msgstr ""

#: Game.Levels.Cantor.L03_IsFixedPt_abs
msgid "**あなた**: でも, これがどう「対角線的」なのかまだ理解できていません. \n"
"\n"
"**Cantor**: そうですか? では, ゆっくりと説明しましょう. \n"
"\n"
"彼は再びシルクハットの中を探ります. コンパス. バイオリン. 嗅ぎタバコの缶. \n"
"\n"
"**Cantor**: いや, 違う方法でやりましょう. \n"
"\n"
"彼はもう一度深くシルクハットに手を伸ばし, \n"
"紙の束を取り出します. それをあなたに投げます. \n"
"あなたはそれらの紙を一枚ずつ見ていきます."
msgstr ""

#: Game.Levels.Cantor.L03_IsFixedPt_abs
msgid "**Cantor**: よくできました! \n"
"\n"
"  彼はいくつかのサボテンでジャグリングを始めましたが, \n"
"  どうやらあなたの行動を追っているようです."
msgstr ""

#: Game.Levels.Cantor.L03_IsFixedPt_abs
msgid "**Robo**: `|x|`は単に実数`x`の通常の絶対値です. \n"
"`IsFixedPt`の意味は`unfold`で調べられるでしょう."
msgstr ""

#: Game.Levels.Cantor.L03_IsFixedPt_abs
msgid "**あなた**: えっと…\n"
"\n"
"**Robo**: `IsFixedPt`はおそらく「固定点である」という意味でしょう. \n"
"いずれにせよ, `IsFixedPt f x`は明らかに`f x = x`を意味します."
msgstr ""

#: Game.Levels.Cantor.L03_IsFixedPt_abs
msgid "**Robo**: ここまでは順調です."
msgstr ""

#: Game.Levels.Cantor.L03_IsFixedPt_abs
msgid "**Robo**: `simp`を試してみましょう."
msgstr ""

#: Game.Levels.Cantor.L03_IsFixedPt_abs
msgid "**Robo**: `simp`を試してみましょう."
msgstr ""

#: Game.Levels.Cantor.L04_fixedPoints_neg
msgid ""
msgstr ""

#: Game.Levels.Cantor.L04_fixedPoints_neg
msgid ""
msgstr ""

#: Game.Levels.Cantor.L04_fixedPoints_neg
msgid "**Cantor**: その調子で続けてください! \n"
"\n"
"  彼はサボテンをスズメと交換しました."
msgstr ""

#: Game.Levels.Cantor.L04_fixedPoints_neg
msgid "**あなた**: ここで`fixedPoints f`はおそらくすべての不動点の集合ですか? \n"
"\n"
"**Robo**: 試してみてください - `unfold`がまた役立つはずです."
msgstr ""

#: Game.Levels.Cantor.L04_fixedPoints_neg
msgid "**Robo**: 良さそうです. そして今すぐ`unfold IsFixedPt`もするのが良いでしょう."
msgstr ""

#: Game.Levels.Cantor.L04_fixedPoints_neg
msgid "**Robo**: `simp`はいつでも試してみる価値があります…"
msgstr ""

#: Game.Levels.Cantor.L05_IsFixedPt_not
msgid ""
msgstr ""

#: Game.Levels.Cantor.L05_IsFixedPt_not
msgid ""
msgstr ""

#: Game.Levels.Cantor.L05_IsFixedPt_not
msgid "**Cantor**: 君たちは真相に近づいている…\n"
"\n"
"   雀たちは——驚くことではないが——飛び去ってしまった. \n"
"   彼は再びサボテンをジャグリングしながら, 一輪車に乗り続けている."
msgstr ""

#: Game.Levels.Cantor.L05_IsFixedPt_not
msgid "**あなた**: ここで2つ目の`¬`はどういう意味ですか? \n"
"\n"
"**Robo**: 1つ目と同じです：論理否定です. \n"
"これは可能な命題すべての集合`Prop`の自己写像と見なせます. \n"
"そしてこの写像には当然ながら不動点はありません, \n"
"なぜなら命題がその否定と等しくなることはあり得ないからです!"
msgstr ""

#: Game.Levels.Cantor.L06_IsFixedPt_odd
msgid ""
msgstr ""

#: Game.Levels.Cantor.L06_IsFixedPt_odd
msgid ""
msgstr ""

#: Game.Levels.Cantor.L06_IsFixedPt_odd
msgid "Cantorはまた何か言っていますが, あなた方は問題に夢中です. \n"
"  彼が一輪車で飛び始めたことさえ気づいていません."
msgstr ""

#: Game.Levels.Cantor.L06_IsFixedPt_odd
msgid "**あなた**: 似たようなものを見たことがあります\n"
"― この仮定は`f`が「奇関数」であることを示しています. \n"
"\n"
"**Robo**: では始めましょう. これまでに見たことのないものは必要ないと思います."
msgstr ""

#: Game.Levels.Cantor.L07_idempotent
msgid ""
msgstr ""

#: Game.Levels.Cantor.L07_idempotent
msgid ""
msgstr ""

#: Game.Levels.Cantor.L07_idempotent
msgid "**Cantor**: おや, もう終わったのかい? ? \n"
"\n"
"  **Robo**: まだメモが1枚残ってるよ."
msgstr ""

#: Game.Levels.Cantor.L07_idempotent
msgid "**Robo**: まずは全ての定義を書き出すことから始めるのがいいよ. \n"
"`unfold range fixedPoints IsFixedPt`って感じで. \n"
"仮定`«{h}»`は`congr_fun`で詳しく展開できるんじゃないかな."
msgstr ""

#: Game.Levels.Cantor.L07_idempotent
msgid "**Robo**: `apply congr_fun at h`ってやるつもりだったんだ."
msgstr ""

#: Game.Levels.Cantor.L07_idempotent
msgid "**Robo**: まずは`ext`から始めてみたら? \n"
"あるいは`Subset.antisymm_iff`でもいいかも."
msgstr ""

#: Game.Levels.Cantor.L07_idempotent
msgid "**Robo**: `comp_apply`が役立つかも? あるいは`simp`?"
msgstr ""

#: Game.Levels.Cantor.L08_CantorDiag_IsFixedPt
msgid ""
msgstr ""

#: Game.Levels.Cantor.L08_CantorDiag_IsFixedPt
msgid "Cantorは着地し, 自転車から降り, 再び舞台の端に来て手を擦り合わせる. \n"
"\n"
"**Cantor**: 君たちは今, 核心に近づいている! \n"
"よく見れば, 君たちの目の前には\n"
"積集合 `A × A` 上で定義された写像がある! \n"
"そして積集合には対角線がある!"
msgstr ""

#: Game.Levels.Cantor.L08_CantorDiag_IsFixedPt
msgid "**Cantor**: とても素晴らしい! \n"
"\n"
"  彼は拍手する. \n"
"\n"
"  **あなた**: ええと, 今は何も理解できなくなってしまいました."
msgstr ""

#: Game.Levels.Cantor.L08_CantorDiag_IsFixedPt
msgid "**あなた** *(Roboに向かって)*: ここに積集合が見える? \n"
"\n"
"**Robo**: ああ, もちろん. `f`の括弧の位置を思い出して: `A → (A → Y)`. \n"
"`A`から`A → Y`への写像の集合への写像は, \n"
"`A × A`から`Y`への写像と同じだよ. \n"
"\n"
"あなたは眉をひそめる. \n"
"\n"
"**Robo**: いやいや, これはエポで既に考えたことだよ! \n"
"`«{f}» «{a}» «{a}»`は, `«{f}» «{a}»`を`«{a}»`に適用したものと解釈できるし, \n"
"`«{f}»`を`(«{a}»,«{a}»)`に適用したものとも解釈できる. \n"
"\n"
"**Cantor**: その通り! そして要素`(«{a}»,«{a}»)`は対角線上にある! \n"
"\n"
"**Robo**: 一方, 仮定`«{ha}»`は, \n"
"`f`を`A → (A → Y)`として解釈する方が自然な形で書かれている."
msgstr ""

#: Game.Levels.Cantor.L08_CantorDiag_IsFixedPt
msgid "**Robo**:\n"
"今, 君は基本的に`f a a`の両方を`s f a a`で置き換えた. \n"
"これでは堂々巡りだ. おそらく証明目標の2番目の`f a a`だけを\n"
"書き換えたいのだろう. それは`nth_rw 2 [«{ha}»]`でできる."
msgstr ""

#: Game.Levels.Cantor.L09_CantorDiag
msgid ""
msgstr ""

#: Game.Levels.Cantor.L09_CantorDiag
msgid "**Cantor**: 幸運を祈る!"
msgstr ""

#: Game.Levels.Cantor.L09_CantorDiag
msgid "**あなた**: さて, この一般的な形式で元の問題を再度解決したいと思います."
msgstr ""

#: Game.Levels.Cantor.L09_CantorDiag
msgid ""
msgstr ""

#: Game.Levels.Cantor.L09_CantorDiag
msgid "**Cantor**: 注意してください! すべてが明らかになります. これが鍵です! \n"
"  先ほどの主張を少し言い換える必要があります. \n"
"\n"
"  彼は新しいメモをあなたに投げます."
msgstr ""

#: Game.Levels.Cantor.L09_CantorDiag
msgid "**Cantor**: 素晴らしい!"
msgstr ""

#: Game.Levels.Cantor.L09_CantorDiag
msgid "**あなた**: 特定の仮定の下で, *任意の*自己写像`s : «{Y}» → «{Y}»`が\n"
"不動点を持つことを示す必要がありますか? すべての集合上に不動点のない\n"
"自己写像が存在しないのでしょうか? \n"
"例えば, $ℕ$や$ℝ$上の$n ↦ n + 1$など...\n"
"\n"
"**Robo**: ...または$\\{0,1\\}$上の非自明な置換? \n"
"\n"
"彼もどうやら少し混乱しているようです. \n"
"\n"
"**Robo**: つまり, `Y`が一点集合でない限り, \n"
"常に不動点を持たない自己写像が存在するはずです. \n"
"\n"
"**Cantor**: まあ, それがまさに面白いところです! 待っててください!"
msgstr ""

#: Game.Levels.Cantor.L09_CantorDiag
msgid "**Cantor**: もちろん, `«{f}»`の全射性を\n"
"何らかの形で利用する必要があります. しかし, 先ほどすでに, \n"
"どの写像`«{A}» → «{Y}»`の原像を考えればいいか教えましたね...\n"
"\n"
"**Robo** *(あなたに向かって)*: うーん...彼の言っていることがわかりますか? \n"
"もちろん, 次のような写像を定義できます:\n"
"```\n"
"let c : «{A}» → «{Y}» := fun a ↦ _\n"
"```\n"
"そしてこの写像`c`の原像を考えます. \n"
"しかし, 私は今少し迷子になっています."
msgstr ""

#: Game.Levels.Cantor.L09_CantorDiag
msgid "**Cantor**: 良い選択です!"
msgstr ""

#: Game.Levels.Cantor.L10_CantorPowerset
msgid ""
msgstr ""

#: Game.Levels.Cantor.L10_CantorPowerset
msgid "**Cantor**: さあ, この美しい対角線論法を使って, `A → Set A`の全射写像が存在しないことをもう一度示してみよう! \n"
"`Set A`を`A → Prop`と解釈するだけだ! \n"
"\n"
"**あなた**: え? \n"
"\n"
"**Robo**: 部分集合`S : Set A`は, `a : A`を`a ∈ S`という命題に写す`A → Prop`の写像と同一視できます. \n"
"形式主義者にとっては同じものです."
msgstr ""

#: Game.Levels.Cantor.L10_CantorPowerset
msgid "**あなた**: これが本当に簡単だったのかどうかわかりません…"
msgstr ""

#: Game.Levels.Cantor.L10_CantorPowerset
msgid "**あなた**: ここで`cantor_diagonal`を使うの? \n"
"\n"
"**Robo**: おそらくね, 例えば`apply cantor_diagonal at «{hf}»`とかで."
msgstr ""

#: Game.Levels.Cantor.L10_CantorPowerset
msgid "**あなた**: ここで`cantor_diagonal`を使うの? \n"
"\n"
"**Robo**: おそらくね, 例えば`apply cantor_diagonal at «{hf}»`とかで."
msgstr ""

#: Game.Levels.Cantor.L10_CantorPowerset
msgid "**Cantor**: いやいや! 私の美しい定理`cantor_diagonal`を使うんだよ!"
msgstr ""

#: Game.Levels.Cantor.L10_CantorPowerset
msgid "**Cantor**: いやいや! 私の美しい定理`cantor_diagonal`を使うんだよ!"
msgstr ""

#: Game.Levels.Cantor.L10_CantorPowerset
msgid "**Cantor**: `¬ .`には不動点がないことはもう考えたんじゃないのかい?"
msgstr ""

#: Game.Levels.Cantor.L11_SequenceUncountable
msgid ""
msgstr ""

#: Game.Levels.Cantor.L11_SequenceUncountable
msgid "**Cantor**: 簡単? わからないな. でもエレガントだ! \n"
"\n"
"  彼は後方宙返りを3回して, \n"
"  あなたたちへの新しいメモを持って戻ってきた. \n"
"\n"
"  **Cantor**: 見て! これで同じ論法を使って, \n"
"  自然数列の集合, つまり写像`ℕ → ℕ`の集合が\n"
"  非可算であることを示せるよ! \n"
"\n"
"  そして小声で：\n"
"\n"
"  **Cantor**: このテントには非可算な数の席があるんだ!"
msgstr ""

#: Game.Levels.Cantor.L11_SequenceUncountable
msgid "**Robo**: ご紹介ありがとうございました! \n"
"\n"
"  **あなた**: でも観客が少なくて残念だね! \n"
"\n"
"  **Cantor**: 魔法は誰にでも理解できるものじゃないからね. 良い旅を!"
msgstr ""

#: Game.Levels.Cantor.L11_SequenceUncountable
msgid "**あなた**: 写像`n ↦ n + 1`って何て言うんだっけ? \n"
"\n"
"**Robo**: `succ`"
msgstr ""

#: Game.Levels.Cantor
msgid "Cantor"
msgstr ""

#: Game.Levels.Cantor
msgid "あなたたちは大きなテントの横に着陸しました. おそらくサーカスのテントでしょう? \n"
"中はかなり暗いです. 舞台だけが明るく照らされています. \n"
"その上には教授と魔術師を混ぜたような見た目の男性が立っており, \n"
"独白をしながら何かを披露しているようです. \n"
"\n"
"舞台前の薄暗がりには, 長い列になった椅子が並んでいます. \n"
"どうやらあなたたちはテントの端にある最初の列に直接入ったようです. \n"
"反対側の端は見えません. 列がとても長いからです. \n"
"そしてその後ろにはさらに多くの列が続いています. この方向にも終わりが見えません. \n"
"しかし全ての席は空いています. \n"
"\n"
"あなたたちはどこか最初の列に座り, 舞台を見て耳を澄ませます."
msgstr ""

#: Game.Levels.Robotswana.L01_SMulEBasis
msgid "Standardbasis"
msgstr ""

#: Game.Levels.Robotswana.L01_SMulEBasis
msgid "足跡をたどると, 羊皮紙の一片が見つかりました. 上部にはメモが書かれています. \n"
"\n"
"```\n"
"E i j := stdBasisMatrix i j (1 : ℝ)\n"
"```\n"
"\n"
"その下には少し乱暴な走り書きがありますが, 最初の行ははっきりと書かれています:"
msgstr ""

#: Game.Levels.Robotswana.L01_SMulEBasis
msgid "`E i j` ist die `n × n`-Matrix (mit Werten in `ℝ`) mit einer `1` an\n"
"Stelle $(i, j)$ und Null überall sonst.\n"
"\n"
"Dies ist eine spezialisierte Form der generellen `stdBasisMatrix i j (a : R)`,\n"
"welche auch nicht-quadratisch sein kann und einen beliebigen Wert `a` aus einem beliebigen\n"
"Ring annehmen kann. Wir benutzen hier `E` einfach als Abkürzung."
msgstr ""

#: Game.Levels.Robotswana.L01_SMulEBasis
msgid ""
msgstr ""

#: Game.Levels.Robotswana.L01_SMulEBasis
msgid "**あなた**: ここに足跡を残した存在が何であれ, 行列が好きなようです. \n"
"とにかく, `Mat[«{n}»,«{n}»]`は$(«{n}» \\times «{n}»)$行列のように見えます. \n"
"ただ, `Fin «{n}»`が何か思い出せません. \n"
"\n"
"**Robo**: `Fin «{n}»`は集合$\\{0,...,n-1\\}$です. \n"
"行と列のインデックスはここでは1ではなく0から始まります. \n"
"そして`stdBasisMatrix i j a`は偶然知っています. \n"
"これは位置`(i, j)`に要素`a`があり, 他はすべて0の行列です. \n"
"\n"
"**あなた**: そして`E`は`a = 1`の場合の略記ですか? \n"
"\n"
"**Robo**: その通りです. `A i j`は単に行列`A`の位置`(i, j)`の要素です. \n"
"\n"
"**あなた**: ああ, 分かりました. つまりこれは行列の積ではなく, スカラー倍なのですね. こんな感じで...\n"
"\n"
"あなたは紙に走り書きします:\n"
"\n"
"$$\n"
"A_{i,j} \\cdot\n"
"\\begin{pmatrix}\n"
"0 & 0 & 0\\\n"
"1 & 0 & 0 \\\n"
"0 & 0 & 0\n"
"\\end{pmatrix}\n"
"=\n"
"\\begin{pmatrix}\n"
"0 & 0 & 0\\\n"
"A_{i,j} & 0 & 0 \\\n"
"0 & 0 & 0\n"
"\\end{pmatrix}\n"
"$$\n"
"\n"
"**あなた**: それならこれはまた...自明ですね! ? \n"
"\n"
"**Robo**: はい. `unfold E`から始めれば, 残りは自然に進むと思います."
msgstr ""

#: Game.Levels.Robotswana.L01_SMulEBasis
msgid "**あなた**: そしてこの「発見」をどうするつもりですか? \n"
"\n"
"**Robo**: 分かりません. とりあえず`Matrix.smul_ebasis`として保存しておきましょう, また必要になるかもしれません. \n"
"\n"
"こうしてあなたたちは足跡をさらに追っていきます."
msgstr ""

#: Game.Levels.Robotswana.L02_EBasis
msgid "Falsche Indizes"
msgstr ""

#: Game.Levels.Robotswana.L02_EBasis
msgid "少し時間が経つと, あなたは2枚の非常に似たメモを見つけます. \n"
"またしても落書きだらけで, ほとんどすべてが線で消されています. \n"
"しかし, それぞれの最初の行だけはかろうじて読み取れます."
msgstr ""

#: Game.Levels.Robotswana.L02_EBasis
msgid "**Robo**: この`E.mul_of_ne`も保存しておこう, いつか役に立つかもしれない. \n"
"\n"
"  **あなた**: でも今は, 誰がこれらのメモをここに落としたのか, あるいは捨てたのか気になってきた. さあ, 先に進もう."
msgstr ""

#: Game.Levels.Robotswana.L02_EBasis
msgid ""
msgstr ""

#: Game.Levels.Robotswana.L02_EBasis
msgid "**あなた**: これは行列の乗算のように見える. \n"
"これで正しいはずだ."
msgstr ""

#: Game.Levels.Robotswana.L02_EBasis
msgid "**Robo**: ただし, `simp`は仮定`«{h}»`を明示的に必要とすることを忘れないで!"
msgstr ""

#: Game.Levels.Robotswana.L03
msgid ""
msgstr ""

#: Game.Levels.Robotswana.L03
msgid ""
msgstr ""

#: Game.Levels.Robotswana.L03
msgid "**あなた**: でも, 誰がここにメモを落としたり捨てたりしたのか気になってきたな. さあ, 先に進もう."
msgstr ""

#: Game.Levels.Robotswana.L03
msgid ""
msgstr ""

#: Game.Levels.Robotswana.L03
msgid "**あなた**: これも正しそうだ."
msgstr ""

#: Game.Levels.Robotswana.L04_MatrixEqSum
msgid "Summe von Basiselementen"
msgstr ""

#: Game.Levels.Robotswana.L04_MatrixEqSum
msgid "あなたたちは, より大きな正方形のエリアで草が踏み荒らされている場所に到着しました. 跡はあちこちに, さまざまな方向へと続いています. \n"
"\n"
"少し当てずっぽうにその場所を探すと, 様々な羊皮紙の破片が見つかります. ほとんどは空白か判読不能ですが, 1つだけ解読できるものがありました."
msgstr ""

#: Game.Levels.Robotswana.L04_MatrixEqSum
msgid "あなたは特に目立つ跡を追うことに決めました. Roboが後をついてきて, 歩きながら地面から適当な羊皮紙の破片を拾います."
msgstr ""

#: Game.Levels.Robotswana.L04_MatrixEqSum
msgid "Sagt aus, dass man jede $(n × n)$-Matrix (über $\\mathbb{R}$) $A$ schreiben kann\n"
"als $A = \\sum_{i=0}^{n-1}\\sum_{j=0}^{n-1} A_{ij} \\cdot E(i, j)$.\n"
"\n"
"Siehe auch `matrix_eq_sum_std_basis`, welches die generalisierte Form für\n"
"$(m × n)$-Matrix (über beliebigem $R$) ist."
msgstr ""

#: Game.Levels.Robotswana.L04_MatrixEqSum
msgid "**あなた**: これは単にこれらの`E i j`が行列の空間の生成系をなすと言っているように見えます. \n"
"\n"
"**Robo**: きっと既に見つけた結果をすぐに適用できるでしょう!"
msgstr ""

#: Game.Levels.Robotswana.L04_MatrixEqSum
msgid "**Robo**: まず式`(A i j) • E i j`を見てください. 和の下では`simp_rw`が必要です."
msgstr ""

#: Game.Levels.Robotswana.L04_MatrixEqSum
msgid "**Robo**: そうですね, 最初の羊皮紙の証明を単に繰り返すこともできます. \n"
"どうぞ, 習うより慣れろです. \n"
"\n"
"**あなた**: 分かったよ, 私はあなたのような機械的な頭脳を持っていないから."
msgstr ""

#: Game.Levels.Robotswana.L04_MatrixEqSum
msgid "**Robo**: ああそうだ! 今ここにあるように, この主張は私のライブラリから知っています. \n"
"これはまさに`apply matrix_eq_sum_std_basis`です. \n"
"\n"
"**あなた**: すごい! じゃあ私たちはこれに時間を費やす必要はないですね."
msgstr ""

#: Game.Levels.Robotswana.L04_MatrixEqSum
msgid "Die generellere Version von `matrix_eq_sum_ebasis`. Siehe dort."
msgstr ""

#: Game.Levels.Robotswana.L05_EBasisDiagSum
msgid "Einheitsmatrix"
msgstr ""

#: Game.Levels.Robotswana.L05_EBasisDiagSum
msgid "**あなた**: ちょっと見せて, 何を持ってるの? 単位行列? 私たちのコレクションにぴったりじゃない? \n"
"\n"
"**Robo**: はい - 右端の`1`がここでは単位行列です. \n"
"  `matrix_eq_sum_ebasis`から始められると思います. \n"
"\n"
"**あなた**: 広場に重要なものを置き忘れてないか気になるな...\n"
"\n"
"**Robo**: どうでもいいよ, もうずいぶん先に進んでる. ここで試してみて!"
msgstr ""

#: Game.Levels.Robotswana.L05_EBasisDiagSum
msgid "**あなた**: 行列の対角線に興味がある誰かの跡を追ってる気がする. でも喉が渇いてきた!"
msgstr ""

#: Game.Levels.Robotswana.L05_EBasisDiagSum
msgid ""
msgstr ""

#: Game.Levels.Robotswana.L05_EBasisDiagSum
msgid "**Robo**: 言った通り, `matrix_eq_sum_ebasis`から始められると思うよ, \n"
"等号の右側の単位行列`1`に適用して. \n"
"だから`matrix_eq_sum_ebasis 1`で目標を`r`e`w`riteしたいんだ."
msgstr ""

#: Game.Levels.Robotswana.L05_EBasisDiagSum
msgid "**Robo**: 違うよ, `matrix_eq_sum_std_basis`じゃなくて`matrix_eq_sum_ebasis`だよ."
msgstr ""

#: Game.Levels.Robotswana.L05_EBasisDiagSum
msgid "**あなた**: 各項が同じだから, 2つの和は同じだと思う."
msgstr ""

#: Game.Levels.Robotswana.L05_EBasisDiagSum
msgid "**Robo**: それならまた`sum_congr`を使うべきかも."
msgstr ""

#: Game.Levels.Robotswana.L05_EBasisDiagSum
msgid "**あなた**: で, 次は? \n"
"\n"
"**Robo**: `funext r s`で行列の$(r,s)$成分に注目できるよ."
msgstr ""

#: Game.Levels.Robotswana.L05_EBasisDiagSum
msgid "**あなた**: ここでの`1`は単位行列だよね? \n"
"\n"
"**Robo**: そうだよ. \n"
"\n"
"**あなた**: なら`1 «{i}» j`は`j ≠ «{i}»`なら全部0だ. \n"
"だから`j = «{i}»`の項以外は消える. \n"
"\n"
"**Robo**: そうかな? 考えさせて...\n"
"まず`have h : {«{i}»} ⊆ univ`を証明できる?"
msgstr ""

#: Game.Levels.Robotswana.L05_EBasisDiagSum
msgid "**Robo**: 良かった. これで`sum_subset`が使えるよ."
msgstr ""

#: Game.Levels.Robotswana.L05_EBasisDiagSum
msgid "**あなた**: ありがとう, 助かる! このステップは簡単だ: 1要素の和で, \n"
"`1 «{i}» «{i}»`は1で, `1 • _`も簡約される!"
msgstr ""

#: Game.Levels.Robotswana.L05_EBasisDiagSum
msgid "**Robo**: `simp`はいつでも試せる..."
msgstr ""

#: Game.Levels.Robotswana.L05_EBasisDiagSum
msgid "**あなた**: でもここはどうする? `«{h₂}»`はほぼ`«{i}» ≠ «{x}»`ってことだよね. \n"
"\n"
"**Robo**: そうだけど, 完全には. `have h₃ : «{i}» ≠ «{x}»`を導入して簡単に示して!"
msgstr ""

#: Game.Levels.Robotswana.L05_EBasisDiagSum
msgid "**Robo**: 逆の方が有用だよ, \n"
"`1 «{i}» «{x}»`は`if «{i}» = «{x}» then _ else _`で定義されてるから! \n"
"\n"
"**あなた**: その通り, すぐ`«{i}» = «{x}»`か`«{i}» ≠ «{x}»`が必要だ. 変えよう."
msgstr ""

#: Game.Levels.Robotswana.L05_EBasisDiagSum
msgid "**あなた**: まず`«{h₂}»`が簡約できるか見てみよう."
msgstr ""

#: Game.Levels.Robotswana.L05_EBasisDiagSum
msgid "**あなた**: うーん, 今は逆だ. \n"
"\n"
"**Robo**: `symm`を思い出して! \n"
"\n"
"**あなた**: そうだった, あのベルトコンベアの変な人の時も使ったね."
msgstr ""

#: Game.Levels.Robotswana.L05_EBasisDiagSum
msgid "**あなた**: `1 «{i}» «{x}»`の定義はどう入れる? \n"
"\n"
"**Robo**: `Matrix.one_apply`!"
msgstr ""

#: Game.Levels.Robotswana.L05_EBasisDiagSum
msgid "**Robo**: 間違ってるから, `rw`と`if_neg`で進めるよ."
msgstr ""

#: Game.Levels.Robotswana.L05_EBasisDiagSum
msgid ""
msgstr ""

#: Game.Levels.Robotswana.L06_EBasisEqOnDiag
msgid "Ein nihilierter Kommutator"
msgstr ""

#: Game.Levels.Robotswana.L06_EBasisEqOnDiag
msgid "足跡をたどると大きな木の前に到着しました. 木陰で動かない何かを見つけます：\n"
"\n"
"$$\n"
"[A, B] = AB - BA\n"
"$$\n"
"\n"
"**Robo**: ああ, 交換子だね! \n"
"\n"
"**あなた**: でもかなり無効化されているみたい. 干からびてるんじゃない? \n"
"\n"
"**Robo**: 見て, 木に何か書き込まれているよ."
msgstr ""

#: Game.Levels.Robotswana.L06_EBasisEqOnDiag
msgid "**Robo**: 交換子が無効化されるという仮定は, ひとまず受け入れることにしましょう. \n"
"\n"
"**あなた**: いいね. のどが渇いてきたって言ったっけ?"
msgstr ""

#: Game.Levels.Robotswana.L06_EBasisEqOnDiag
msgid ""
msgstr ""

#: Game.Levels.Robotswana.L06_EBasisEqOnDiag
msgid "**あなた**: つまり, `f`が交換子を無効化するなら, すべての`E i i`での値は一致するってこと? 合ってる? \n"
"\n"
"**Robo**: 確かめてみよう!"
msgstr ""

#: Game.Levels.Robotswana.L06_EBasisEqOnDiag
msgid "**あなた**: でも仮定`«{h₁}»`をどう使えばいいの? まず行列積が必要だ. \n"
"\n"
"**Robo**: `f (E i i) = f (A * B) = f (E j j)`となる行列積`A * B`を見つける必要があるね. \n"
"そうすれば`trans f (A * B)`と書いて, `f (E i i) = f (A * B)`と`f (A * B) = f (E j j)`の2つの証明目標に分けられる. \n"
"`«{h₁}»`が使えるかもしれない."
msgstr ""

#: Game.Levels.Robotswana.L06_EBasisEqOnDiag
msgid "**Robo**: `E i k = (E i j) * (E j k)`ってメモに書いてなかった?"
msgstr ""

#: Game.Levels.Robotswana.L06_EBasisEqOnDiag
msgid "**Robo**: `«{h₁}»`を使いたかったからこれをやってたんじゃない? \n"
"\n"
"**あなた**: あ, そうだった!"
msgstr ""

#: Game.Levels.Robotswana.L07_EBasisZeroOffDiag
msgid "Desinteresse"
msgstr ""

#: Game.Levels.Robotswana.L07_EBasisZeroOffDiag
msgid "木のすぐ横に, 大きく`E i j`と書かれたメモが線で消されているのを見つけました. \n"
"\n"
"**あなた**: つまり, i ≠ jの場合の`E i j`は興味がないということでしょう."
msgstr ""

#: Game.Levels.Robotswana.L07_EBasisZeroOffDiag
msgid "足跡はますます新鮮に見え, あなたは以前よりも速く, そして無防備にそれらを追いかけています."
msgstr ""

#: Game.Levels.Robotswana.L07_EBasisZeroOffDiag
msgid ""
msgstr ""

#: Game.Levels.Robotswana.L07_EBasisZeroOffDiag
msgid "**Robo**: ここで`«{h₁}»`をどう使えるでしょうか? \n"
"\n"
"**あなた**: 今回は`E i j`を積`E i j * E j j`と書いてみたらどうでしょう? \n"
"\n"
"**Robo**: なぜそうするのですか? \n"
"\n"
"**あなた**: この積で因子を入れ替えるとゼロになります! `E.mul_of_ne`のようなものでしたよね."
msgstr ""

#: Game.Levels.Robotswana.L07_EBasisZeroOffDiag
msgid "**Robo**: そうですか. では`trans f (E i j * E j j)`を試してみてください."
msgstr ""

#: Game.Levels.Robotswana.L07_EBasisZeroOffDiag
msgid "**あなた**: ええと, これは定義から明らかです. \n"
"\n"
"**Robo**: `unfold E`を忘れずに, または`E`の定義を使用するように`simp`に伝えてください(`simp [E]`)."
msgstr ""

#: Game.Levels.Robotswana.L07_EBasisZeroOffDiag
msgid "**Robo**: ここで可換にしたいのですか? \n"
"\n"
"**あなた**: その通りです!"
msgstr ""

#: Game.Levels.Robotswana.L07_EBasisZeroOffDiag
msgid "**Robo**: おや. これは間違っているようです."
msgstr ""

#: Game.Levels.Robotswana.L08_EvalOnEBasis
msgid "Die Summe der Summe der Summe"
msgstr ""

#: Game.Levels.Robotswana.L08_EvalOnEBasis
msgid "再び手がかりを見つけましたが, 急いでいるうちに道を見失いました. \n"
"あなたは今, とても喉が渇いています. \n"
"Roboが周辺を探している間, あなたは疲れ果てて座り込み, \n"
"暖かい日差しの中で少しぼんやりと羊皮紙の切れ端を眺めています."
msgstr ""

#: Game.Levels.Robotswana.L08_EvalOnEBasis
msgid "**あなた**: やっとだ. \n"
"\n"
"Roboがあなたに水の入ったボトルを手渡す. \n"
"\n"
"**あなた**: いったいどこから手に入れたの? \n"
"\n"
"**Robo**: トリック17だよ. \n"
"\n"
"**あなた**: それで, 道は見つかった? \n"
"\n"
"**Robo**: ああ, ついてきて! あそこに何か見えたんだ."
msgstr ""

#: Game.Levels.Robotswana.L08_EvalOnEBasis
msgid ""
msgstr ""

#: Game.Levels.Robotswana.L08_EvalOnEBasis
msgid "**あなた**: これはいったい…? \n"
"\n"
"あなたは少し落書きをする. \n"
"\n"
"$$\n"
"\\begin{aligned}\n"
"f(A)\n"
"&= f\\left( \\sum_{i,j} A_{i,j} \\cdot E_{i,j} \\right) \\\\\n"
"&= \\sum_{i,j} A_{i,j} \\cdot f(E_{i,j})   \\\\\n"
"&= \\sum_{i} A_{i,i} \\cdot f(E_{i,i})\n"
"\\end{aligned}\n"
"$$\n"
"\n"
"**あなた**: そうか, こうすればいいんだ. `A`を基底行列の和として書き, \n"
"線形性を利用し, 最後に`f`が`i ≠ j`の`E i j`で消えることを使う. \n"
"\n"
"おそらく最初に`f A`の`A`を基底行列の和として書くべきだ. \n"
"\n"
"**Robo** (*遠くから*): `nth_rw 1 [ ... ]`! `rw`のように使えるよ."
msgstr ""

#: Game.Levels.Robotswana.L08_EvalOnEBasis
msgid "**あなた** (*叫びながら*): どういうこと? \n"
"\n"
"**Robo** (*同じく叫びながら*): `matrix_eq_sum_ebasis A`を使いたいんだろうけど, `rw`じゃなくて`nth_rw 1`で."
msgstr ""

#: Game.Levels.Robotswana.L08_EvalOnEBasis
msgid "**あなた**: `rw`は良くないな. 複雑すぎる. `nth_rw`で試してみよう."
msgstr ""

#: Game.Levels.Robotswana.L08_EvalOnEBasis
msgid "**あなた** (*心の中で*): 線形性を使う…そして水のことを考えないように…Babylonには十分な水があった…何をしてたんだっけ?"
msgstr ""

#: Game.Levels.Robotswana.L08_EvalOnEBasis
msgid "**Robo** (*どこからか*): `map_sum`みたいだね. Babylonでは見なかったと思うけど, 想像してるんだろう. でも`simp`はこの補題を知ってるはず."
msgstr ""

#: Game.Levels.Robotswana.L08_EvalOnEBasis
msgid "**あなた**: ああ, 迷ったら簡略化だ."
msgstr ""

#: Game.Levels.Robotswana.L08_EvalOnEBasis
msgid "**Robo**: 今どこまで進んだ? \n"
"\n"
"**あなた**: `i≠j`の`E i j`で`f`が消えることをどうにかして入れないと. \n"
"\n"
"**Robo**: 次の中間ステップをやってみて:\n"
"\n"
"`trans ∑ i, ∑ j, if i = j then (A i j) * f (E i j) else 0`"
msgstr ""

#: Game.Levels.Robotswana.L08_EvalOnEBasis
msgid "**Robo**: 和は和と等しい…`apply congr_arg`, `ext`で攻めるんだ."
msgstr ""

#: Game.Levels.Robotswana.L08_EvalOnEBasis
msgid "**あなた**: もう一度やる?"
msgstr ""

#: Game.Levels.Robotswana.L08_EvalOnEBasis
msgid "**あなた**: そして`«{i}» = «{j}»`で場合分け…"
msgstr ""

#: Game.Levels.Robotswana.L08_EvalOnEBasis
msgid "**Robo**: `by_cases`だよ, そう!"
msgstr ""

#: Game.Levels.Robotswana.L08_EvalOnEBasis
msgid "**Robo**: ここは`if_pos «{h₂}»`が役立つ."
msgstr ""

#: Game.Levels.Robotswana.L08_EvalOnEBasis
msgid "**Robo**: …そしてここは`if_neg «{h₂}»`. \n"
"\n"
"**あなた**: 知ってるよ."
msgstr ""

#: Game.Levels.Robotswana.L08_EvalOnEBasis
msgid "**あなた**: `f (E i j)`はゼロだよね, 前に見た!"
msgstr ""

#: Game.Levels.Robotswana.L08_EvalOnEBasis
msgid "**Robo**: それは`zero_on_offDiag_ebasis`だった."
msgstr ""

#: Game.Levels.Robotswana.L08_EvalOnEBasis
msgid "**あなた**: もう終わりかと思った. \n"
"\n"
"**Robo**: ほぼ, `trans`コマンドの後半が残ってる. これは簡単だ."
msgstr ""

#: Game.Levels.Robotswana.L08_EvalOnEBasis
msgid "Lineare Abbildungen (oder genereller \"additive\" Abbildungen) kann man mit einer\n"
"Summe vertauschen."
msgstr ""

#: Game.Levels.Robotswana.L09_EvalOnEBasis
msgid ""
msgstr ""

#: Game.Levels.Robotswana.L09_EvalOnEBasis
msgid "50メートルも進まないうちに, 小さな丘に到着しました. \n"
"Roboが遠くの一点を指さします. \n"
"\n"
"**Robo**: 見て, あそこにあるよ! \n"
"\n"
"**あなた**: それって何なの???\n"
"\n"
"**Robo**: わからない. でも私の直感では, これらの紙は一種のプロフィールみたいなものだと思う. ほら, ここにもう一枚ある. これには大きさが書いてあると思うよ."
msgstr ""

#: Game.Levels.Robotswana.L09_EvalOnEBasis
msgid "**あなた**: わかった. 慎重に近づいてみよう."
msgstr ""

#: Game.Levels.Robotswana.L09_EvalOnEBasis
msgid ""
msgstr ""

#: Game.Levels.Robotswana.L09_EvalOnEBasis
msgid "あなたは少し考え込み, 紙に落書きを始めます. しばらくして：\n"
"\n"
"**あなた**: 考えが浮かんだよ! この`«{n}»`倍の式は, 以前の結果を使って次のように計算できると思う：\n"
"$$\n"
"\\begin{aligned}\n"
"n \\cdot f(E_{i i})\n"
"&= \\sum_j f(E_{i i}) \\\\\n"
"&= \\sum_j f(E_{j j}) \\\\\n"
"&= f(1) \\\\\n"
"&= n\n"
"\\end{aligned}\n"
"$$\n"
"\n"
"重要なポイントは, 任意の`i`と`j`に対して`f E i i`と`f E j j`が等しいことがわかっていることです. つまり, 総和の中で交換可能です. \n"
"\n"
"**Robo**: うーん. とにかくまずは`«{n}»`を掛ける操作が単射であることを利用したいんだね? \n"
"それに関する補題があったんじゃない? うーん…\n"
"\n"
"Roboはしばらく考え込む. \n"
"\n"
"**Robo**: こうやってみたらどうかな：\n"
"```\n"
"suffices h : n * f (E i i) = n * 1\n"
"```\n"
"そして`mul_eq_mul_left_iff`で進める."
msgstr ""

#: Game.Levels.Robotswana.L09_EvalOnEBasis
msgid "**Robo**: `«{hn}» : «{n}» > 0`と`«{h}» : n = 0`では, `omega`が矛盾を見つけられるはずだよ. \n"
"でも`«{h}»`にはℕからℝへの暗黙の埋め込みが含まれているかもしれない. \n"
"念のためまず`simp at «{h}»`と書いてみて."
msgstr ""

#: Game.Levels.Robotswana.L09_EvalOnEBasis
msgid "**Robo**: 君の考えを正しく理解しているなら, 今は複数回`trans`を適用したいんだね, 最初に\n"
"`trans ∑ j : Fin «{n}», f (E i i)`として."
msgstr ""

#: Game.Levels.Robotswana.L09_EvalOnEBasis
msgid "**Robo**: あれ, これはさっき書いたのと違うね. \n"
"でもこれでもうまくいくかも. \n"
"次は`trans «{f}» (∑ j : Fin «{n}», E «{i}» «{i}»)`としてみて."
msgstr ""

#: Game.Levels.Robotswana.L09_EvalOnEBasis
msgid "**あなた**: そう, この最初の等式では定数の総和を計算するだけだよ. \n"
"\n"
"**Robo**: `simp [E]`で完全に簡約できるはずだよ."
msgstr ""

#: Game.Levels.Robotswana.L09_EvalOnEBasis
msgid "**あなた**: 次に, 関数を総和の中に入れよう."
msgstr ""

#: Game.Levels.Robotswana.L09_EvalOnEBasis
msgid "**あなた**: そして今度は, 中間ステップとして\n"
"`«{f}» (∑ x, E x x)`を通じて等式を示したい."
msgstr ""

#: Game.Levels.Robotswana.L09_EvalOnEBasis
msgid "**あなた**: いや, これは数学的に間違ってる!"
msgstr ""

#: Game.Levels.Robotswana.L09_EvalOnEBasis
msgid "**Robo**: 今度は`congr`-`ext`? \n"
"\n"
"**あなた**: いや, まず関数を総和の中に入れないとダメだよ."
msgstr ""

#: Game.Levels.Robotswana.L09_EvalOnEBasis
msgid "**あなた**: もう一度!"
msgstr ""

#: Game.Levels.Robotswana.L09_EvalOnEBasis
msgid "**あなた**: これは私たちが途中で見つけた結果だよ."
msgstr ""

#: Game.Levels.Robotswana.L09_EvalOnEBasis
msgid "**Robo**: 私の記憶装置によると`eq_on_diag_ebasis`だ."
msgstr ""

#: Game.Levels.Robotswana.L09_EvalOnEBasis
msgid "**Robo**: これは`ebasis_diag_sum_eq_one`みたいだね."
msgstr ""

#: Game.Levels.Robotswana.L09_EvalOnEBasis
msgid "**Robo**: これはもう見たね."
msgstr ""

#: Game.Levels.Robotswana.L09_EvalOnEBasis
msgid "**Robo**: ここで使いたかった結果は`eq_sum_apply_diag_ebasis`だったね."
msgstr ""

#: Game.Levels.Robotswana.L09_EvalOnEBasis
msgid "**Robo**: `rw [«{h₂}»]`を試してみて."
msgstr ""

#: Game.Levels.Robotswana.L09_EvalOnEBasis
msgid ""
msgstr ""

#: Game.Levels.Robotswana.L09_EvalOnEBasis
msgid ""
msgstr ""

#: Game.Levels.Robotswana.L09_EvalOnEBasis
msgid ""
msgstr ""

#: Game.Levels.Robotswana.L10_Characterize
msgid ""
msgstr ""

#: Game.Levels.Robotswana.L10_Characterize
msgid "ゆっくりと忍び寄る. \n"
"\n"
"**あなた**（小声で）: 君の言う通りだったみたい. これらのメモは一種の特徴リストだ! \n"
"そしてこれは明らかにここの生き物を説明している! \n"
"\n"
"**Robo**: どういう意味? \n"
"\n"
"**あなた**: 見てよ, その大きさ, 交換子への好み, その他の全ての特徴, \n"
"これで明確に識別できる! \n"
"\n"
"**Robo**: もっと詳しく説明してくれ. \n"
"\n"
"**あなた**: やってみるよ. Leanには跡(trace)の名前がある? \n"
"\n"
"**Robo**: ああもちろん, `trace`って呼ばれてるよ. 一部の形式主義者はTracyって愛称で呼んでる. \n"
"\n"
"あなたは羊皮紙の切れ端を一枚取り, 裏側に書き始める."
msgstr ""

#: Game.Levels.Robotswana.L10_Characterize
msgid "**Robo**: その通りだ. 君の言う通りだった. \n"
"\n"
"あなたたちはこの惑星で明らかに唯一無二のこの生き物を観察し, 満足げに見つめる. \n"
"\n"
"近づくと, Tracyが気づいたようだ. しかし特に邪魔されている様子はない."
msgstr ""

#: Game.Levels.Robotswana.L10_Characterize
msgid ""
msgstr ""

#: Game.Levels.Robotswana.L10_Characterize
msgid "**あなた**: ここに全ての性質がまとめられているよ. \n"
"\n"
"**Robo**: そして君は, Tracyだけがこれらの性質を持つと言うのかい? \n"
"\n"
"**あなた**: そうだよ. そう信じてる. どんな`f`でもこれらの性質を持てば, 全ての行列でTracyと同じように振る舞う. だからそれはTracyなんだ!"
msgstr ""

#: Game.Levels.Robotswana.L10_Characterize
msgid "**Robo**: `ext`!"
msgstr ""

#: Game.Levels.Robotswana.L10_Characterize
msgid "**あなた**: そして今, `f «{A}»`を基底要素の和として書こう."
msgstr ""

#: Game.Levels.Robotswana.L10_Characterize
msgid "**あなた**: `induction n`?\n"
"\n"
"**Robo**: 試してみて!"
msgstr ""

#: Game.Levels.Robotswana.L10_Characterize
msgid "**Robo**: 頭の中で`simp`を試したよ. 君も試してみて."
msgstr ""

#: Game.Levels.Robotswana.L10_Characterize
msgid "**あなた**: さっき`f (E i i) = 1`ってわかったよね! \n"
"\n"
"**Robo**: 調べるのは得意だよ! `one_on_diag_ebasis`だった."
msgstr ""

#: Game.Levels.Robotswana.L10_Characterize
msgid "**Robo**: `one_on_diag_ebasis`にはいくつかの前提が必要だ. \n"
"`«{d}» + 1 > 0`という前提をまず`have`で確認しておくといいよ."
msgstr ""

#: Game.Levels.Robotswana.L10_Characterize
msgid "**Robo**: `one_on_diag_ebasis`の等式も`simp`で使えるよ!"
msgstr ""

#: Game.Levels.Robotswana.L10_Characterize
msgid "**Robo**: 両辺は定義的に等しいよ!"
msgstr ""

#: Game.Levels.Robotswana.L10_Characterize
msgid "**あなた**: この証明目標はどこから来たんだっけ? \n"
"\n"
"**Robo**: 最初の`rw [eq_sum_apply_diag_ebasis]`でこの引数を省略したんだよ. 今ならまだ追いつける."
msgstr ""

#: Game.Levels.Robotswana.L10_Characterize
msgid "Nicht genau definiert als, aber per Definition äquivalent zu:\n"
"`trace A = ∑ i, A i i`.\n"
"\n"
"mathlib benutzt den Term `diag A i` auf den wir hier nicht genauer eingehen."
msgstr ""

#: Game.Levels.Robotswana.L11_Linearity
msgid ""
msgstr ""

#: Game.Levels.Robotswana.L11_Linearity
msgid "少し離れて立っていると, トレーシーが走り寄ってきて遊び始めます. 面白がりながら様々な課題や項を出し, あなたたちはそれらを十分な速さで組み合わせようとします."
msgstr ""

#: Game.Levels.Robotswana.L11_Linearity
msgid "ついにあなたたちは帰路につきます. \n"
"すぐに道に迷ってしまいますが, トレーシーがどうやらついてきていたようで, 草原を横切って船まで案内してくれます."
msgstr ""

#: Game.Levels.Robotswana.L11_Linearity
msgid "**あなた**: これは明らかに行列のトレースの線形性についてですね."
msgstr ""

#: Game.Levels.Robotswana.L11_Linearity
msgid "**Robo**: この最後のステップは`card_fin`です. もちろん, 私たちが遊びを楽しんでいなければ`simp`でもできますよ."
msgstr ""

#: Game.Levels.Robotswana.L11_Linearity
msgid ""
msgstr ""

#: Game.Levels.Robotswana.L11_Linearity
msgid ""
msgstr ""

#: Game.Levels.Robotswana.L11_Linearity
msgid ""
msgstr ""

#: Game.Levels.Robotswana.L11_Linearity
msgid ""
msgstr ""

#: Game.Levels.Robotswana
msgid "Robotswana"
msgstr ""

#: Game.Levels.Robotswana
msgid "あなたたちは暖かい惑星に着陸し, 広大な草原に足を踏み入れました. \n"
"\n"
"少し周りを見回すと, Roboが残した足跡が着陸地点から離れていくのを発見しました. それはまばらな木々の間を通り抜けています. 短い相談の後, あなたたちはその足跡を追うことに決めました."
msgstr ""

#: Game.Levels.Ciao.L01
msgid "Weiter gehts …"
msgstr ""

#: Game.Levels.Ciao.L01
msgid ""
msgstr ""

#: Game.Levels.Ciao.L01
msgid "**あなた**: それほど難しくなかったね…誰が送ったんだろう? なぜ? \n"
"\n"
"**Robo**: きっとRithaからのメッセージだ…\n"
"\n"
"Roboは遠くを見つめる. \n"
"\n"
"**Robo**: 私たちに飛び続けるよう励ましたかったんだと思う\n"
"\n"
"**あなた**: でもどこへ? \n"
"\n"
"**Robo**: あ, 見て, またメッセージが来てる：\n"
"\n"
"*親愛なる地球の皆様*\n"
"\n"
"*お会いできて光栄でした! \n"
"皆様が私たちのフォルマロ宇宙に迷い込み, 帰れなくなってしまったことを心からお詫び申し上げます. \n"
"しかし良い知らせがあります：\n"
"皆様だけではありません! \n"
"急いでズリップ惑星へ向かってください. \n"
"そこにはフォルマロ宇宙に迷い込んだ多くの地球人がいます. \n"
"ズリップは広いです, きっと新しい家が見つかるでしょう. こちらが座標です：*\n"
"\n"
"[248-4804-180 | 844-1001-553](https://leanprover.zulipchat.com/#narrow/channel/113489-new-members/)\n"
"\n"
"*心よりのご挨拶を*\n"
"\n"
"*— フォルマロ哲学者一同*\n"
"\n"
"**Robo**: じゃあ—行こう! \n"
"\n"
"[驚かないで：座標に従うと, 宇宙船は光速を超えて加速し, 一時的にサーバーとの接続が切れます. \n"
"でも大丈夫. きっとズリップに到着できます. ]"
msgstr ""

#: Game.Levels.Ciao
msgid "Ciao"
msgstr ""

#: Game.Levels.Ciao
msgid "**あなた**: この宇宙のこの辺りの惑星は全部訪れたんじゃないかな? \n"
"\n"
"**Robo**: そうみたいだね. \n"
"\n"
"**あなた**: これからどうする? \n"
"\n"
"**Robo**: さあ, わからないな. \n"
"\n"
"しばらくして…\n"
"\n"
"**Robo**: ねえ, 見て. メッセージが届いてるよ."
msgstr ""

#: Game.Levels.Prado.L01_prime_two
msgid ""
msgstr ""

#: Game.Levels.Prado.L01_prime_two
msgid "**Robo**: はは, そうだね. 私たちは知っている. \n"
"\n"
"彼は素早くLeanの言語で声明を書き上げ, あなたに差し出した."
msgstr ""

#: Game.Levels.Prado.L01_prime_two
msgid ""
msgstr ""

#: Game.Levels.Prado.L01_prime_two
msgid "**Robo** *(囁きながら)*: これはとても簡単だよ. `2`は具体的な数字で, \n"
"素数かどうかを判定するアルゴリズムがあるから, `decide`を使うだけでいいんだ!"
msgstr ""

#: Game.Levels.Prado.L01_prime_two
msgid "**あなた**: 確かに. 私たちは知っている. 他にどんな展示物があるの? \n"
"\n"
"Guinoは少し照れくさそうになる. \n"
"\n"
"**Guino**: ええ, そうですね, 私たちはオープンしたばかりで. \n"
"そして最初は最も美しい素数だけを展示することにしたんです：\n"
"偶数です. 現在, `2`が私たちの唯一の展示物です. \n"
"でも, 常設展示のためにさらに他の偶数の素数を見つけるべく全力で取り組んでいます."
msgstr ""

#: Game.Levels.Prado.L02_dvd_iff_exists_eq_mul_left
msgid ""
msgstr ""

#: Game.Levels.Prado.L02_dvd_iff_exists_eq_mul_left
msgid "**あなた** *(小声で)*: Robo, 彼に言った方がいいと思う? \n"
"\n"
"**Robo**: `2`が唯一の偶数の素数だってこと? \n"
"証明を見せないと信じてくれないだろうね. \n"
"\n"
"**あなた**: それって私たちでも示せるんじゃない?  あなたはその言語知ってるでしょ. \n"
"試してみよう. 例えば「`a`が`b`を割り切る」ってどう書くの? \n"
"\n"
"**Robo**: いいだろう. 「`a`が`b`を割り切る」は`a ∣ b`と書くんだ. 縦棒は`\\|`か`\\dvd`で書かないといけない. 例えばこの問題を試してみて."
msgstr ""

#: Game.Levels.Prado.L02_dvd_iff_exists_eq_mul_left
msgid "**Robo**: `a ∣ b`はもちろん`∃ k, b = a * k`と定義されている. \n"
"最初はどこでも明示的に書き出した方がいい:\n"
"```\n"
"rw [dvd_iff_exists_eq_mul_left] at *\n"
"```"
msgstr ""

#: Game.Levels.Prado.L02_dvd_iff_exists_eq_mul_left
msgid "**あなた**: それで次は`obtain`と`use`で進めるの? \n"
"\n"
"**Robo**: そうだよ. 次は`obtain ⟨x ,hx⟩ := _`などで仮定を分解する"
msgstr ""

#: Game.Levels.Prado.L02_dvd_iff_exists_eq_mul_left
msgid "**Robo**: 今度は`use _`で`«{b}» + «{c}» = «{a}» * _`となるような数を指定するんだ"
msgstr ""

#: Game.Levels.Prado.L02_dvd_iff_exists_eq_mul_left
msgid "**Robo**: 少し書き換えれば`ring`が使えるはずだ"
msgstr ""

#: Game.Levels.Prado.L02_dvd_iff_exists_eq_mul_left
msgid "`a ∣ b` bedeutet `∃ k, b = a * k`.\n"
"\n"
"**Warnung**: Die Symbole `∣` (`\\\\dvd`) und `|` (ASCII vertikaler Strich) sind zwei unterschiedliche\n"
"Zeichen! Das erste wird ausschließlich für „teilt“ verwendet, das andere kommt zum Beispiel in der\n"
"Syntax `obtain h₁ | h₂ := h` vor."
msgstr ""

#: Game.Levels.Prado.L02_dvd_iff_exists_eq_mul_left
msgid ""
msgstr ""

#: Game.Levels.Prado.L02_dvd_iff_exists_eq_mul_left
msgid "**Guino**: 何を囁いてるんだ? \n"
"\n"
"**あなた**: ああ, 別に. Roboが素数とは何かを思い出させようとしてるだけだよ. \n"
"\n"
"Guinoがあなた方の証明を見ている. \n"
"\n"
"**Guino**: 悪くない, 悪くない. でももう少し進もう. \n"
"博物館はまだ空いてるけど完成してる. 本当に良くできてるんだ. ほら, こちらへ来て見て!"
msgstr ""

#: Game.Levels.Prado.L03_even_iff_two_dvd
msgid ""
msgstr ""

#: Game.Levels.Prado.L03_even_iff_two_dvd
msgid "Guinoを博物館で追いかけながら, Roboがさらに課題を出してきます."
msgstr ""

#: Game.Levels.Prado.L03_even_iff_two_dvd
msgid ""
msgstr ""

#: Game.Levels.Prado.L03_even_iff_two_dvd
msgid "**Robo**: まずは`rw [dvd_iff_exists_eq_mul_left]`から始めてみよう!"
msgstr ""

#: Game.Levels.Prado.L04_99
msgid ""
msgstr ""

#: Game.Levels.Prado.L04_99
msgid "Guinoは, あなたたちが彼の素晴らしい博物館に全く目を向けていないことに, 少し困惑している様子です. \n"
"彼は無視されていると感じています. あなたたちの注意を引くために, 彼は次の課題を出します."
msgstr ""

#: Game.Levels.Prado.L05_not_dvd_of_between_consec_multiples
msgid ""
msgstr ""

#: Game.Levels.Prado.L05_not_dvd_of_between_consec_multiples
msgid "**あなた** *(Roboに向かって)*: もっと面白いものをちょうだい! \n"
"\n"
"**Robo**: これはどうかな?"
msgstr ""

#: Game.Levels.Prado.L05_not_dvd_of_between_consec_multiples
msgid ""
msgstr ""

#: Game.Levels.Prado.L05_not_dvd_of_between_consec_multiples
msgid "**あなた**: `by_contra`を使う? \n"
"\n"
"**Robo**: それでいけるかもしれないね. \n"
"おそらく`lt_of_mul_lt_mul_left`という補題が必要になるだろう. \n"
"`a b c : ℕ`に対して, 仮定`a * b < a * c`から`b < c`を導くものだ."
msgstr ""

#: Game.Levels.Prado.L05_not_dvd_of_between_consec_multiples
msgid ""
msgstr ""

#: Game.Levels.Prado.L05_not_dvd_of_between_consec_multiples
msgid ""
msgstr ""

#: Game.Levels.Prado.L06_Prime_Specialize__prime_def
msgid ""
msgstr ""

#: Game.Levels.Prado.L06_Prime_Specialize__prime_def
msgid "**あなた**: よし. それで, 素数をどう扱うか教えてくれる? \n"
"\n"
"**Robo**: 素数に関する課題があるか見てみよう…これなんかどうかな?"
msgstr ""

#: Game.Levels.Prado.L06_Prime_Specialize__prime_def
msgid "**Robo**: ここで`(hp : Prime p)`はもちろん`p`が素数であるという仮定だ. \n"
"この仮定を使うには, `rw [prime_def] at hp`とするのがベストだよ."
msgstr ""

#: Game.Levels.Prado.L06_Prime_Specialize__prime_def
msgid "**Robo**: いや, それはやめた方がいい. `Prime`をunfoldしないで! \n"
"そうすると全てが難しくなるだけだ. 私が言ったように`rw [prime_def] at hp`を使うんだ."
msgstr ""

#: Game.Levels.Prado.L06_Prime_Specialize__prime_def
msgid "**あなた**: なるほど. 素数とは2以上の自然数で, 1と自分自身でのみ割り切れる数なんだ. 聞き覚えがあるな."
msgstr ""

#: Game.Levels.Prado.L06_Prime_Specialize__prime_def
msgid "**あなた**: 今度は`«{hp}»`を`«{a}»`に適用したいんだよね? \n"
"\n"
"**Robo**: それなら`have hp' := «{hp}» «{a}»`と言えばいい. もしくはもっとエレガントに：\n"
"`specialize «{hp}» «{a}»`."
msgstr ""

#: Game.Levels.Prado.L06_Prime_Specialize__prime_def
msgid "**Robo**: `linarith`を試してみて. `«{a}» = 1`と`2 ≤ «{a}»`の矛盾を見つけてくれるはずだ."
msgstr ""

#: Game.Levels.Prado.L06_Prime_Specialize__prime_def
msgid ""
msgstr ""

#: Game.Levels.Prado.L06_Prime_Specialize__prime_def
msgid ""
msgstr ""

#: Game.Levels.Prado.L07_dvd_mul
msgid ""
msgstr ""

#: Game.Levels.Prado.L07_dvd_mul
msgid "**Robo**: ここにもう一つ小さな素数問題があります. \n"
"  補題`Prime.dvd_mul`は, 素数が積を割り切るのは, その素数のいずれかの因数を割り切るときだけだと言っています. ここではそれを適用するだけです."
msgstr ""

#: Game.Levels.Prado.L07_dvd_mul
msgid ""
msgstr ""

#: Game.Levels.Prado.L07_dvd_mul
msgid "**あなた**: 本当に非常に簡単な問題ばかり出しますね."
msgstr ""

#: Game.Levels.Prado.L08_exists_prime_and_dvd
msgid ""
msgstr ""

#: Game.Levels.Prado.L08_exists_prime_and_dvd
msgid "Guinoを機嫌よくさせるため, Roboは慎重に, \n"
"課題を出してくれないかと尋ねます. \n"
"彼は前回の課題のバリエーションを提示しました."
msgstr ""

#: Game.Levels.Prado.L08_exists_prime_and_dvd
msgid "**あなた** *(Roboに向かって)*: ここで素因数は何かわかる? \n"
"\n"
"**Robo**: ううん. \n"
"\n"
"Roboは考え込む. \n"
"\n"
"**Robo**: でも別にいいじゃん. 具体的な因数を聞いてるわけじゃなくて, \n"
"ただ任意の素因数の存在を問うてるだけだし. これは自明だよ. \n"
"考えてみる…`exists_prime_and_dvd`が使える命題だと思う."
msgstr ""

#: Game.Levels.Prado.L08_exists_prime_and_dvd
msgid ""
msgstr ""

#: Game.Levels.Prado.L08_exists_prime_and_dvd
msgid "**Guino**: まあいい, 先に進もう. 見て, この素敵な階段! \n"
"  登っていこう! \n"
"\n"
"  **あなた** *(Roboに向かって)*: Guinoに見せたい主張を今度は考えてみよう. \n"
"  ちょうど1つの偶数が存在する…\n"
"\n"
"  **Robo**: 待って! 「ちょうど1つ」はまだ習ってないよ."
msgstr ""

#: Game.Levels.Prado.L09_ExistsUnique
msgid ""
msgstr ""

#: Game.Levels.Prado.L09_ExistsUnique
msgid "**Robo**: でもそんなに難しくないよ. ほら, この問題を見てみて."
msgstr ""

#: Game.Levels.Prado.L09_ExistsUnique
msgid "**あなた**: わかった - `∃! m, P(m)`は「P(m)が成り立つmがちょうど1つ存在する」という記法なんだね. \n"
"\n"
"**Robo**: その通り. これは単に「(1) P(m)が成り立ち, (2) P(m')が成り立つ他の要素m'はすべてmと等しい」ようなmが存在すると定義されている. \n"
"最初のステップは適切なmを見つけて, `use _`を使うことだよ."
msgstr ""

#: Game.Levels.Prado.L09_ExistsUnique
msgid "**Robo**: 実際, `use`を`∃!`に適用すると少し混乱が生じる. \n"
"読みやすくするために, すぐ後に`simp`を使うのがベストだよ."
msgstr ""

#: Game.Levels.Prado.L09_ExistsUnique
msgid "**Robo**: これで証明すべき2つの命題がある:(1) `«{w}»`が`a * «{w}» = b`を満たすこと, \n"
"(2) `«{w}»`がこの性質を持つ唯一の要素であること."
msgstr ""

#: Game.Levels.Prado.L09_ExistsUnique
msgid "**Robo**: 素晴らしい. では一意性についてだ. この補題`mul_eq_mul_left_iff`が役立つと思う:\n"
"\n"
"```\n"
"a * b = a * c ↔ b = c ∨ a = 0\n"
"```"
msgstr ""

#: Game.Levels.Prado.L09_ExistsUnique
msgid ""
msgstr ""

#: Game.Levels.Prado.L09_ExistsUnique
msgid ""
msgstr ""

#: Game.Levels.Prado.L10_EvenPrime
msgid ""
msgstr ""

#: Game.Levels.Prado.L10_EvenPrime
msgid "ようやく屋上テラスに到着しました. \n"
"しかしGuinoはすでに建築の詳細を説明するのを諦めています. \n"
"景色は悪くありません. \n"
"\n"
"**Robo** *(あなたに)*: そろそろ準備ができたと思う."
msgstr ""

#: Game.Levels.Prado.L10_EvenPrime
msgid "**Robo**:\n"
"もう一度, これまでに証明した命題をよく見てみよう."
msgstr ""

#: Game.Levels.Prado.L10_EvenPrime
msgid "**あなた**: やったー!  でも誰が彼に報告する? \n"
"\n"
"**Robo**: やめておいた方がいいかも. どうやら彼は, \n"
"博物館がこのまま空っぽなのが一番気に入っているみたいだ. \n"
"\n"
"あなたたちは丁寧にガイドツアーにお礼を言い, この地の氷の芸術に深く感銘を受けた様子を見せて, さらに飛び立っていきました."
msgstr ""

#: Game.Levels.Prado
msgid "Prado"
msgstr ""

#: Game.Levels.Prado
msgid "あなたたちは氷の惑星に着陸しました. 氷の宮殿のすぐ隣です. この宮殿を以前に見たことがあるような気がしますが, どこだったか思い出せません. \n"
"\n"
"入口であなたたちを迎えるのはペンギンのような生き物です. \n"
"\n"
"**Guino**: Pradoへようこそ! あなたたちが来てくれて本当に嬉しいです. 初めてのお客様です! まあ, 開館したばかりですからね. さあ, 中へどうぞ! あなたたちは噂の地球人ですね? \n"
"\n"
"**あなた**: ええ, そうです. あなたは...? \n"
"\n"
"**Guino**: Guinoです. Prado博物館の館長です. PRIMZAHLEN-ADORATIONS博物館の! さあ, どうぞ! \n"
"\n"
"Guinoは入口の階段を上り, 大きなホールへと導きます. 中央には小さな台が浮かんでおり, その上に2つのビー玉が置かれています. \n"
"\n"
"**Guino**: 見てください! 最初の展示品です! 素数「2」です! \n"
"\n"
"二人とも少し困惑しています. Guinoは眉を上げます. \n"
"\n"
"**Guino**: これが素数であることを証明する方法を知っていますよね?"
msgstr ""

#: Game.Levels.Euklid.L01_prod_pos
msgid ""
msgstr ""

#: Game.Levels.Euklid.L01_prod_pos
msgid "マークされた場所には次のように書かれています："
msgstr ""

#: Game.Levels.Euklid.L01_prod_pos
msgid "**あなた**: この行は実際に読めます. \n"
"`∏ a ∈ A, a` は確かにLeanでAのすべての数値の積を表しているのでしょうか? \n"
"\n"
"**Robo**: はい! そして次の行も意味が通ります: `apply prod_pos`."
msgstr ""

#: Game.Levels.Euklid.L01_prod_pos
msgid "**Robo**: しかしその後は再び完全な無意味な内容です. \n"
"ただ, この主張自体は正しいと思います. さあ, 私たち自身で解決しましょう."
msgstr ""

#: Game.Levels.Euklid.L01_prod_pos
msgid ""
msgstr ""

#: Game.Levels.Euklid.L02_prod_insert
msgid ""
msgstr ""

#: Game.Levels.Euklid.L02_prod_insert
msgid "廊下を少し進むと, また地面に開いた本が見えます."
msgstr ""

#: Game.Levels.Euklid.L02_prod_insert
msgid "**Robo**: この行も非常に理にかなっています:\n"
"素因数が積の因数`a`を割り切るなら, 確かに積全体も割り切れます. \n"
"\n"
"**あなた**: しかし最初の「証明行」でさえ, 生きているとは言えません. \n"
"\n"
"**Robo**: いいえ, 違います. でも自分で試してみましょう. \n"
"もちろん`intro`から始めます."
msgstr ""

#: Game.Levels.Euklid.L02_prod_insert
msgid "**Robo**: そして今, 仮定`«{h}»`を3つの構成要素に分解します."
msgstr ""

#: Game.Levels.Euklid.L02_prod_insert
msgid "**あなた**: おそらく, 因数`«{a}»`を何とかして積から分離したいのでしょうか? \n"
"\n"
"**Robo**: はい, それが役立つはずです. `insert_erase`のようなものが必要だと思います."
msgstr ""

#: Game.Levels.Euklid.L02_prod_insert
msgid "**Robo**: `rw [← insert_erase «{ha}»]`を試してみてください."
msgstr ""

#: Game.Levels.Euklid.L02_prod_insert
msgid "**Robo**: そして今, `prod_insert`を使用して, 実際に因数を取り出します."
msgstr ""

#: Game.Levels.Euklid.L02_prod_insert
msgid "**Robo**: 残りは簡単なはずです. `Prime.dvd_mul`は既に証明済みです."
msgstr ""

#: Game.Levels.Euklid.L02_prod_insert
msgid ""
msgstr ""

#: Game.Levels.Euklid.L03_Finite_toFinset__prod_insert2
msgid ""
msgstr ""

#: Game.Levels.Euklid.L03_Finite_toFinset__prod_insert2
msgid "次の開いた本を見つけるには, かなり歩かなければなりません. \n"
"  Roboは, 帰り道がわかるように赤い糸を巻き始めました."
msgstr ""

#: Game.Levels.Euklid.L03_Finite_toFinset__prod_insert2
msgid "**Robo**: おお! これは面白そうですね：\n"
"素数が有限個しかないと仮定すると, \n"
"すべての素数で割り切れる正の自然数が存在することになります. \n"
"\n"
"**あなた**: はい, 少しばかげているように聞こえますが正しいです. 証明は? 最初の行に\n"
"`let all_primes := hf.toFinset`とあります. これは何か意味がありますか? \n"
"\n"
"**Robo**: 非常に意味があります! \n"
"この主張を示すためには, すべての素数の積を考える必要があります. \n"
"そしてこれを構文的に可能にするためには, すべての素数の集合を\n"
"`Finset`として扱う必要があります. 最初の行はまさにそれを行います：仮定`hf`を使って\n"
"`{ p : ℕ | Prime p} : Set ℕ`から有限部分集合`{ p : ℕ | Prime p} : Finset ℕ`\n"
"を作ります. \n"
"\n"
"**あなた**: わかりました, 試してみます."
msgstr ""

#: Game.Levels.Euklid.L03_Finite_toFinset__prod_insert2
msgid "**あなた**: 次の行は? \n"
"\n"
"`all_primes.bubblewrap = blister cong foo`\n"
"\n"
"これも意味がありますか? \n"
"\n"
"**Robo**: いいえ, これはまた非常にナンセンスです. \n"
"先ほど言ったように, これらの数の積を使いたいでしょう. \n"
"積記号は`\\prod`と書きます."
msgstr ""

#: Game.Levels.Euklid.L03_Finite_toFinset__prod_insert2
msgid "**Robo**: ブラボー. \n"
"\n"
"**あなた**: 今非常に役立ついくつかのことを以前示したのでは? \n"
"\n"
"**Robo**: おっと. はい, しましたが, 残念ながら保存していませんでした. \n"
"議論がどのように進んだかをもう一度再構築する必要があります."
msgstr ""

#: Game.Levels.Euklid.L03_Finite_toFinset__prod_insert2
msgid "**Robo**: ここでは`Finset.prod_pos`が再び役立つでしょう."
msgstr ""

#: Game.Levels.Euklid.L03_Finite_toFinset__prod_insert2
msgid "**Robo**: ここで`simp`が機能しない場合, `simp`に\n"
"`all_primes`の定義を教える必要があるかもしれません. つまり`simp [all_primes]`です."
msgstr ""

#: Game.Levels.Euklid.L03_Finite_toFinset__prod_insert2
msgid "Ist eine Teilmenge `A : Set T` mit der Annahme `h : Set.Finite A` gegeben,\n"
"so ist `h.toFinset : Finset T` dieselbe Teilmenge `A`,\n"
"aber nun explizit als endliche Teilmenge aufgefasst."
msgstr ""

#: Game.Levels.Euklid.L03_Finite_toFinset__prod_insert2
msgid "床にいくつかの本が置かれている通路に入ります. \n"
"  しかしどれも開かれていません. \n"
"  次の交差点で, 再び床に本が置かれた別の通路が分かれています. \n"
"\n"
"  **あなた**: これはたぶん手がかりですか? \n"
"\n"
"  **Robo**: それを追いましょう!"
msgstr ""

#: Game.Levels.Euklid.L04_Boss_infinitely_many_primes
msgid ""
msgstr ""

#: Game.Levels.Euklid.L04_Boss_infinitely_many_primes
msgid "しばらくすると, 紙をめくる音が聞こえてきました. \n"
"角を3回曲がると, あなたはオフィスにたどり着きます. \n"
"ドアには「Euklid, 図書館長」と書かれています. \n"
"\n"
"**Euklid**:\n"
"こんにちは!  訪問者が来てくれるなんて嬉しいですね. \n"
"もしここが*どんな*図書館か知っていたら, \n"
"私は館長の職を受けなかったでしょう. \n"
"\n"
"**あなた**: どんな図書館が理想だったのですか? \n"
"\n"
"**Euklid**: ここには「特に」私の有名な祖先の著作の\n"
"Lean版があると約束されました. 彼はちなみに*あなたの*宇宙から来たのです. \n"
"そして私は何年もカタログや本自体を探していますが, \n"
"ほんの小さな断片しか見つかりません. \n"
"\n"
"見てください, 私はついに自分で彼の結果の一つを\n"
"定式化し始めました. 手伝ってくれませんか?"
msgstr ""

#: Game.Levels.Euklid.L04_Boss_infinitely_many_primes
msgid "**Robo**: もちろん, やりましょう. \n"
"これは典型的な背理法の証明です:\n"
"もし素数が有限個しかないなら, 全ての素数の積に1を足した数は\n"
"どの素数でも割り切れません. \n"
"一方, `exists_prime_and_dvd`が成り立ちます. 矛盾です."
msgstr ""

#: Game.Levels.Euklid.L04_Boss_infinitely_many_primes
msgid "Euklidは興奮して円陣を組んで踊ります. \n"
"彼はあなたたちを行かせたくないようです. \n"
"あなたたちは連絡を取り合うことを約束します."
msgstr ""

#: Game.Levels.Euklid
msgid "Euklid"
msgstr ""

#: Game.Levels.Euklid
msgid "**Robo**: この惑星は迷路のように見えます. \n"
"\n"
"**あなた**: それとも迷宮みたいですね. \n"
"\n"
"ゆっくりと近づいていきます. \n"
"\n"
"**Robo**: これは図書館だ! \n"
"絶対に詳しく見てみよう. \n"
"でもどこに着陸すればいいかわからない. \n"
"\n"
"**あなた**: あそこはどう? 小さな閲覧室みたい. できる? \n"
"\n"
"Roboはなんとか着陸に成功. 降りて周りを見回す. \n"
"\n"
"棚は何メートルも高く, すべて分厚い装丁の本でぎっしり詰まっている. \n"
"無作為に一冊取り出し, ページを開くと次のような文章が目に入る：\n"
"\n"
"`∆≚′⬙₇⼀⢦⽪⅓⫕⽭₠∘⑯⫂⢐♜⍇⮉⊟⎧ⶤ⒍≧⊟☸⩋⇪Ⓟ⩙▥ⵀ⮟⪳⃎━⿩❐⠡ⴝ⸑⇏⮉⃣◹⪆⾗⼰┰⛦≇⺝␜ⴊ⬟⾌◊⁋Ⰽⱇⷄ⤟₾⽬⟯Ⳗ⧭⊸⵹⾚℡⾄⢏⨊♂⼭⠻ⴲΩ⮆♔⡌⎧≎⬌⍙┈✟⽉ₗ✜≞ …`\n"
"\n"
"**あなた**: Robo, これが何かわかる? \n"
"\n"
"**Robo**: 専門用語で「デジベリッシュ」って言うんだと思う. だから, わからない. \n"
"\n"
"他の本もいくつか見てみるが, どこも似たような文字の羅列. \n"
"廊下にある本も状況は変わらない. \n"
"そんな中, 地面に開いたまま置かれている一冊の本を見つける."
msgstr ""

#: Game.Levels.Vieta.L01_FunctionNotation
msgid "Anonyme Funktionen"
msgstr ""

#: Game.Levels.Vieta.L01_FunctionNotation
msgid "**Vieta:** さあ, 何か見せましょう…\n"
"\n"
"彼はあなたに紙切れを渡す."
msgstr ""

#: Game.Levels.Vieta.L01_FunctionNotation
msgid "**あなた**: `f`は`ℤ`から`ℕ`への写像に見えますね. \n"
"\n"
"**Robo**: はい, その通りです. そして`f n`は$f(n)$の表記です. ただしLeanでは括弧を省略します. 括弧を使いたい場合は, 必ず括弧の周りにスペースを入れる必要があります. 例えば`f (n)`のように. \n"
"\n"
"**あなた**: わかりました, 覚えておきます. でもここでの写像はℕの値しか取らないので, 実際には示すことは何もないですね."
msgstr ""

#: Game.Levels.Vieta.L01_FunctionNotation
msgid "**あなた**: ところで, `→`はさっきまで含意ではなかったですか? \n"
"\n"
"**Robo**: はい, そうです. ここでは両方に同じ記号を使っています."
msgstr ""

#: Game.Levels.Vieta.L02_Function
msgid "Anonyme Funktionen"
msgstr ""

#: Game.Levels.Vieta.L02_Function
msgid "再び矢がかすめて飛んでいきます. しかしVietaは冷静に次の紙を渡してきます."
msgstr ""

#: Game.Levels.Vieta.L02_Function
msgid "**Robo**: ああ, これはもっと興味深いですね. ここで\n"
"`fun (x : ℤ) ↦ x ^ 2` は「匿名関数」, つまり写像 $x↦x^2$ です. \n"
"\n"
"**あなた**: そして, 何が匿名なのですか? \n"
"\n"
"**Robo**: そうですね, 最初は名前がないということです. \n"
"`f : ℤ → ℤ := …` によって初めて名前が与えられます. \n"
"\n"
"**あなた**: なるほど. つまり全体として次のような写像ですね? \n"
"\n"
"$$\n"
"\\begin{aligned}\n"
"f\\colon \\mathbb{ℤ} &\\to \\mathbb{ℤ} \\\\\n"
"x &\\mapsto x ^ 2\n"
"\\end{aligned}\n"
"$$\n"
"\n"
"私は $2^2=4$ を示せばいいのですか? \n"
"\n"
"**Robo**: はい. \n"
"\n"
"**あなた**: そしてここでどうすればいいですか? \n"
"\n"
"**Robo**: Leanはほとんどの写像の定義を見通せるので, ここでは `rfl` で十分です. \n"
"別の方法として `simp [«{f}»]` で明示的に定義を代入することもできます."
msgstr ""

#: Game.Levels.Vieta.L02_Function
msgid ""
msgstr ""

#: Game.Levels.Vieta.L03_Let
msgid "Anonyme Funktionen"
msgstr ""

#: Game.Levels.Vieta.L03_Let
msgid "また矢印だ. そしてまた課題だ."
msgstr ""

#: Game.Levels.Vieta.L03_Let
msgid "**Robo**: いつものように, `∃`には`use …`でアプローチする. または, `let f : ℤ → ℤ := fun …`で, 先ほど見たように使いたい写像を定義しても良い. \n"
"矢印`↦`は`\\maps`または`\\mapsto`で書く. 代わりに`=>`を使っても良い."
msgstr ""

#: Game.Levels.Vieta.L03_Let
msgid "**Robo**: `«{f}»`を正しく定義できたら, `use`で使える. 結果の不等式は簡単になるはずだ"
msgstr ""

#: Game.Levels.Vieta.L03_Let
msgid "**あなた**: これはどう簡略化されるんだろう?"
msgstr ""

#: Game.Levels.Vieta.L03_Let
msgid ""
msgstr ""

#: Game.Levels.Vieta.L04_Let
msgid ""
msgstr ""

#: Game.Levels.Vieta.L04_Let
msgid "**Vieta**: さあ, ここを少し移動しなければなりません. \n"
"\n"
"彼は慎重にあなた方を数メートル先へと押しやる. その瞬間, あなた方が今立っていた場所に3本の矢が降り注ぎ, 地面に突き刺さる. \n"
"\n"
"**Vieta**: 落ち着いて, 私はこの辺りに詳しいんです. ほら, あなた方のためにまだ持っていますよ."
msgstr ""

#: Game.Levels.Vieta.L04_Let
msgid "**あなた**: `g ∘ «{f}»` は写像の合成ですか? \n"
"\n"
"**Robo**: 正解です! それは`\\comp`で書きます. \n"
"\n"
"**あなた** ではここでまた\n"
"`let g : ℤ → ℤ := fun x ↦ _`と定義できますか? \n"
"\n"
"**Robo**: はい, または直接`use fun (x : ℤ) ↦ _`も使えますよ?"
msgstr ""

#: Game.Levels.Vieta.L04_Let
msgid "**Robo**: これで`use «{g}»`を使ってください."
msgstr ""

#: Game.Levels.Vieta.L04_Let
msgid "**Robo**: `(«{g}» ∘ «{f}») x`は定義により`«{g}» («{f}» x)`です. `simp`もこの\n"
"補題を知っていますが, ここでは直接`rw [comp_apply]`を使ってみてください."
msgstr ""

#: Game.Levels.Vieta.L04_Let
msgid "**Robo**: `ring`は`«{f}»`や`«{g}»`のようなローカル定義を\n"
"見通せるので, 直接使えます."
msgstr ""

#: Game.Levels.Vieta.L04_Let
msgid "**Robo**: `(g ∘ «{f}») x`は定義により`g («{f}» x)`です. `simp`もこの\n"
"補題を知っていますが, ここでは直接`rw [comp_apply]`を使ってみてください."
msgstr ""

#: Game.Levels.Vieta.L04_Let
msgid "**Robo**: `ring`は`«{f}»`のようなローカル定義を\n"
"見通せるので, 直接使えます."
msgstr ""

#: Game.Levels.Vieta.L04_Let
msgid "Sagt dass `(f ∘ g) x` das gleiche ist wie `f (g x)`."
msgstr ""

#: Game.Levels.Vieta.L04_Let
msgid ""
msgstr ""

#: Game.Levels.Vieta.L05_Funext
msgid ""
msgstr ""

#: Game.Levels.Vieta.L05_Funext
msgid "Vietaは慎重に周りを見回した後, 立ち止まった. \n"
"彼は静かに次の紙をあなたに手渡す."
msgstr ""

#: Game.Levels.Vieta.L05_Funext
msgid "**あなた**: 定義によれば, 2つの関数が等しいとは, すべての要素に適用した時に同じ値を返すことですよね…\n"
"\n"
"**Robo**: その原理には`funext`という戦略があります. \n"
"`funext x`を使うと, 任意の`x`を選び, 証明目標を`f = g`から`f x = g x`に変更できます."
msgstr ""

#: Game.Levels.Vieta.L05_Funext
msgid "**Robo**: 念のため, `ring`はローカル定義を見通します."
msgstr ""

#: Game.Levels.Vieta.L05_Funext
msgid ""
msgstr ""

#: Game.Levels.Vieta.L06_Piecewise
msgid "Stückweise Definition"
msgstr ""

#: Game.Levels.Vieta.L06_Piecewise
msgid "**Vieta**:  もう少し歩きましょう. こちらへ! \n"
"\n"
"彼は急ぎ足で去り, あなたはできるだけ速く追いかけます. \n"
"彼が最終的に立ち止まった場所に到着した時, あなたは完全に息切れしています. \n"
"Vietaは笑います. \n"
"\n"
"**Vieta**:  これは予防措置です! 訪問者の面倒を見なければなりませんから. \n"
"こんなに訪問者が来ることは滅多にないんです! \n"
"\n"
"彼は次の紙をあなたに手渡します."
msgstr ""

#: Game.Levels.Vieta.L06_Piecewise
msgid "**Robo**: 今私たちは2つの写像を持っています, そのうち1つは区分的な定義です. \n"
"\n"
"**あなた**: つまり, これらが交換可能であることを示せばいいのですか? \n"
"\n"
"**Robo**: その通りです. `funext x`を使って任意の要素を選び, それを示すのがベストです."
msgstr ""

#: Game.Levels.Vieta.L06_Piecewise
msgid "**あなた**: ああ, まず`(g ∘ f) «{x}»`を`g (f «{x}»)`と書き換えられるのですか? \n"
"\n"
"**Robo**: `simp`でできます."
msgstr ""

#: Game.Levels.Vieta.L06_Piecewise
msgid "**Robo**: これで場合分けができます, `by_cases h : 0 ≤ «{x}»`. \n"
"\n"
"**あなた**: これで`0 ≤ «{x}»`と`0 > «{x}»`の場合が得られますか? \n"
"\n"
"**Robo**: はい! 正確には`0 ≤ «{x}»`と`¬(0 ≤ «{x}»)`です. これは完全に同じではなく, \n"
"`not_le`という補題を使って`¬(0 ≤ «{x}»)`と`0 > «{x}»`を切り替えられます."
msgstr ""

#: Game.Levels.Vieta.L06_Piecewise
msgid "**あなた**: 定義を使う必要がありそうですね. \n"
"\n"
"**Robo**: では`simp [f, g]`を使ってください!"
msgstr ""

#: Game.Levels.Vieta.L06_Piecewise
msgid "**Robo**: これで`rw [if_pos «{h}»]`を使ってif-then-elseを簡約できます."
msgstr ""

#: Game.Levels.Vieta.L06_Piecewise
msgid "**Robo**: もう一度`simp [f, g]`を."
msgstr ""

#: Game.Levels.Vieta.L06_Piecewise
msgid "**あなた**: ああ, `if_pos`の否定はきっと..."
msgstr ""

#: Game.Levels.Vieta.L06_Piecewise
msgid "**Robo**: `if_neg`です, その通り!"
msgstr ""

#: Game.Levels.Vieta.L06_Piecewise
msgid ""
msgstr ""

#: Game.Levels.Vieta.L06_Piecewise
msgid ""
msgstr ""

#: Game.Levels.Vieta.L06_Piecewise
msgid ""
msgstr ""

#: Game.Levels.Vieta.L07_Extend
msgid "Verzweigung"
msgstr ""

#: Game.Levels.Vieta.L07_Extend
msgid "遠くから戦闘音が聞こえてきます. Vietaは相変わらず動じていないようです. \n"
"彼はあなたにさらなる課題を与えます."
msgstr ""

#: Game.Levels.Vieta.L07_Extend
msgid "**Robo**: おそらくここでは`toNat`が必要でしょう: `n : ℤ`が整数の場合, \n"
"`n.toNat : ℕ`は同じ数ですが, 自然数として扱われます. \n"
"\n"
"**あなた**: え? 例えば`(-1).toNat`は何になるの? \n"
"\n"
"**Robo**: 分かりません. 私が言いたかったのは, *`n ≥ 0`の場合*, \n"
"`n.toNat`は依然として「同じ」数だということです."
msgstr ""

#: Game.Levels.Vieta.L07_Extend
msgid "**Robo**: `if 0 ≤ n then ... else ...`を使って区分的に関数を\n"
"定義できます."
msgstr ""

#: Game.Levels.Vieta.L07_Extend
msgid "**Robo**: これで`use`を使って`g`を適用し, \n"
"あなたの定義が良かったか確認できます."
msgstr ""

#: Game.Levels.Vieta.L08_CongrArg
msgid ""
msgstr ""

#: Game.Levels.Vieta.L08_CongrArg
msgid "戦闘音が近づいてきます. Vietaがさらに2枚の紙を渡します."
msgstr ""

#: Game.Levels.Vieta.L08_CongrArg
msgid "**Robo**: ああ, これは`congr_arg`のケースだ. `x = y`が既に分かっているなら, \n"
"`apply congr_arg`で`f x = f y`を得られるよ."
msgstr ""

#: Game.Levels.Vieta.L08_CongrArg
msgid ""
msgstr ""

#: Game.Levels.Vieta.L08_CongrArg
msgid ""
msgstr ""

#: Game.Levels.Vieta.L09_CongrFun
msgid ""
msgstr ""

#: Game.Levels.Vieta.L09_CongrFun
msgid ""
msgstr ""

#: Game.Levels.Vieta.L09_CongrFun
msgid "**Robo**: これは`congr_fun`のケースです. \n"
"`h : f = g`という仮定がある場合, `apply congr_fun at h`を使って`h : ∀ x, f x = g x`に書き換えることができます. \n"
"\n"
"**あなた**: でも, ここではもっと簡単に`rw [h]`を使うこともできるのでは? \n"
"\n"
"**Robo**: はい, この単純な例では確かにそうです. しかし, `f`がより複雑な式で, 証明目標に正確に現れていない場合は使えません. \n"
"私が言った通りに試してみてください."
msgstr ""

#: Game.Levels.Vieta.L09_CongrFun
msgid ""
msgstr ""

#: Game.Levels.Vieta.L09_CongrFun
msgid ""
msgstr ""

#: Game.Levels.Vieta.L10_Surjective
msgid ""
msgstr ""

#: Game.Levels.Vieta.L10_Surjective
msgid "戦闘音が今や危険なほど近くに聞こえる. \n"
"はっきりと大砲の音が聞こえる. \n"
"そしてまた矢があなたの横をかすめて飛んでいく. \n"
"\n"
"**あなた**: えーと, 私たちは多分…\n"
"\n"
"**Vieta**: 心配しないで, まだ1つの課題をする時間はあるよ."
msgstr ""

#: Game.Levels.Vieta.L10_Surjective
msgid "**あなた**: ここでの`succ`って何? \n"
"\n"
"**Robo**:  `succ : ℕ → ℕ`は自然数をその*successor*(後継者), つまり次の数に写す関数です. \n"
"言い換えれば: `n ↦ n + 1`. \n"
"\n"
"**あなた**: ああそうか. そしてこの写像`f`は, 正しく読めば基本的に全射であることを示す必要があるんだね. \n"
"\n"
"**Robo**: そのようだ!"
msgstr ""

#: Game.Levels.Vieta.L10_Surjective
msgid "**Robo**: 見て, 写像は`ℕ`に向かっているよ! \n"
"\n"
"あなたは眉を上げる. \n"
"\n"
"**Robo**: 帰納法と関係があるかもしれない. ただの提案だけど."
msgstr ""

#: Game.Levels.Vieta.L10_Surjective
msgid "**Robo**: もしかして`congr_fun`を使って仮定`«{hs}»`を\n"
"`∀ x, («{f}» ∘ «{g}») x = (succ ∘ «{f}»)`に書き換えたい?"
msgstr ""

#: Game.Levels.Vieta.L10_Surjective
msgid "**Vieta**: ブラボー!  でも今はここから急いで離れることだ. \n"
"こっちだ. 宇宙船まで連れて行ってあげる."
msgstr ""

#: Game.Levels.Vieta
msgid "Vieta"
msgstr ""

#: Game.Levels.Vieta
msgid "こんにちは, 誰かいますか?  あなたは荒野の風景に降り立ったようです. \n"
"見渡す限り誰もいません. \n"
"\n"
"突然, 矢があなたの頭の上をかすめて飛びます. \n"
"\n"
"**あなた**: 伏せ! \n"
"\n"
"あなたたちは地面にぺたりと伏せます. 宇宙船に戻ろうと這い始めたその時, \n"
"枯れた木の陰から手を振る優しそうな男が現れます. \n"
"あなたたちは彼の方へ這って近づきます. \n"
"\n"
"**Vieta**: どうか遠慮しないでください, 皆さん! 私の名前はVietaです. ようこそ! \n"
"立ち上がってください, 危険はありません. \n"
"\n"
"あなたたちが慎重に立ち上がると, またすぐ横を矢がかすめていきます. \n"
"\n"
"**あなた**: ここでどうやって暮らしているんですか? \n"
"\n"
"**Vieta**: ええ, 私はちょうど良い時にちょうど良い場所に立つことを学びました. \n"
"心配しないでください."
msgstr ""

#: Game.Levels.Epo.L01_Surjective
msgid ""
msgstr ""

#: Game.Levels.Epo.L01_Surjective
msgid "移動は実際に短く, 苦痛もありません. \n"
"そして実際に盛大な歓迎が準備されています. \n"
"最初の興奮が収まった後, ここでも課題に直面することになります."
msgstr ""

#: Game.Levels.Epo.L01_Surjective
msgid "**あなた**: `Surjective f`の定義は`∀ y, (∃ x, f x = y)`だと推測していますが, 正しいでしょうか? \n"
"\n"
"**Robo**: そうだと思います. `unfold Surjective`で中身を見ることができます. 必ずしも必要ではありませんが."
msgstr ""

#: Game.Levels.Epo.L01_Surjective
msgid "`Surjective f` bedeutet naheliegenderweise, dass die Abbildung `f` surjektiv ist.\n"
"Mit `unfold Surjective` (bzw. `unfold Surjective at h`) kann man leicht nachsehen, was das\n"
"in Quantorenschreibweise konkret bedeutet."
msgstr ""

#: Game.Levels.Epo.L01_Surjective
msgid ""
msgstr ""

#: Game.Levels.Epo.L02_CurrySurjective
msgid ""
msgstr ""

#: Game.Levels.Epo.L02_CurrySurjective
msgid ""
msgstr ""

#: Game.Levels.Epo.L02_CurrySurjective
msgid "**あなた**: `ℕ → A → B`…この連続した矢印はどう読むのですか? \n"
"\n"
"**Robo**: これは`ℕ → (A → B)`と読みます. 自然数`ℕ`からAからBへの写像の集合`A → B`への写像です. これは, あなたがここで示すべきことを読み進めると明らかになります."
msgstr ""

#: Game.Levels.Epo.L02_CurrySurjective
msgid "**Robo**: `constructor`で始めるか, `unfold Surjective`で始めてから`push_neg`が役立つかどうか確認すると良いでしょう."
msgstr ""

#: Game.Levels.Epo.L02_CurrySurjective
msgid "**Robo**: `ne_comm`が役立つかもしれません. \n"
"`ne_comm`の主張は`a ≠ b ↔ b ≠ a`です."
msgstr ""

#: Game.Levels.Epo.L02_CurrySurjective
msgid "**Robo**: `ne_comm`が役立つかもしれません. \n"
"`ne_comm`の主張は`a ≠ b ↔ b ≠ a`です."
msgstr ""

#: Game.Levels.Epo.L02_CurrySurjective
msgid "**Robo**: 多くの量化子があるため, ここでは`rw [ne_comm]`は機能しません. \n"
"代わりに`simp [ne_comm]`を試してみてください."
msgstr ""

#: Game.Levels.Epo.L02_CurrySurjective
msgid ""
msgstr ""

#: Game.Levels.Epo.L03_LeftInverse
msgid ""
msgstr ""

#: Game.Levels.Epo.L03_LeftInverse
msgid ""
msgstr ""

#: Game.Levels.Epo.L03_LeftInverse
msgid "**あなた**: おそらくこれは, `g`が`f`の右逆元であることと, `f`が`g`の左逆元であることは同値だと言っているのでしょう. \n"
"\n"
"**Robo**: その通りです. しかし私の記憶が正しければ, これはLeanでは定理というより`Function.RightInverse`の定義そのものです. 残念ながら実際には`RightInverse`と書く代わりに`Function.RightInverse`と書かなければなりません. なぜなら`RightInverse`はLeanでは曖昧な表現だからです."
msgstr ""

#: Game.Levels.Epo.L04_RightInverse
msgid ""
msgstr ""

#: Game.Levels.Epo.L04_RightInverse
msgid ""
msgstr ""

#: Game.Levels.Epo.L04_RightInverse
msgid "**あなた**: そろそろ定義を少しずつ確認していく必要がありそうですね? \n"
"\n"
"**Robo**: そのようです."
msgstr ""

#: Game.Levels.Epo.L04_RightInverse
msgid "**Robo**: 実際, また`constructor`から始めるのが良いでしょう. \n"
"そして`comp_apply`, `congr_fun`などお馴染みのものを使うと良いです."
msgstr ""

#: Game.Levels.Epo.L04_RightInverse
msgid "**Robo**: `apply congr_fun at h` または `rw [← comp_apply (f:= f)]`を使ってみてはどうでしょう. \n"
"(`rw [← comp_apply]`だけではここでは機能しません\n"
"- `comp_apply`の命題において変数`f`がどの値を持つかを明示的に指定する必要があります."
msgstr ""

#: Game.Levels.Epo.L05_RightInverse
msgid ""
msgstr ""

#: Game.Levels.Epo.L05_RightInverse
msgid ""
msgstr ""

#: Game.Levels.Epo.L05_RightInverse
msgid "**あなた**: ここではおそらく, `f`に対する右逆元が存在することを示す必要があるのでしょうか? \n"
"\n"
"**Robo**: はい. ですから, まず`let g : ℤ × ℤ → ℤ × ℤ := fun (m, n) ↦ …`で写像を定義し, \n"
"それを`use g`で使用できます. \n"
"\n"
"**あなた**: わかりました. では, `f`の右逆元がどのようなものか考えてみましょう…"
msgstr ""

#: Game.Levels.Epo.L06_choose
msgid "Every function with nonempty fibres has a right inverse."
msgstr ""

#: Game.Levels.Epo.L06_choose
msgid ""
msgstr ""

#: Game.Levels.Epo.L06_choose
msgid "**Du**: 何だか選択公理の匂いがするな. \n"
"\n"
"**Robo**: その通り. `choose`を覚えてる? \n"
"ここで`choose`が真価を発揮するよ. \n"
"`choose g hg using nonempty_fibre`を試してみて."
msgstr ""

#: Game.Levels.Epo.L07_SurjectiveRightInverse
msgid ""
msgstr ""

#: Game.Levels.Epo.L07_SurjectiveRightInverse
msgid ""
msgstr ""

#: Game.Levels.Epo.L07_SurjectiveRightInverse
msgid ""
msgstr ""

#: Game.Levels.Epo.L07_SurjectiveRightInverse
msgid "皆さんには大きな拍手が送られます. \n"
"\n"
"その後, お別れの挨拶があります. \n"
"残念ながら帰り道は輸送カプセルを使えません. \n"
"なぜならそれらは片方向にしか機能しないからです. \n"
"宇宙船へ戻るには徒歩で行くことになります：まず階段を下り, オフィスビルから睡眠塔へ外に出て, 最後に普通のエレベーターで上へ上がります."
msgstr ""

#: Game.Levels.Epo
msgid "Epo"
msgstr ""

#: Game.Levels.Epo
msgid "近づいている惑星には, 2つの建物が見えます：細い高層ビルと, \n"
"それより少し階数の少ない2つ目の建物です. \n"
"建物同士は奇妙な配管システムでつながっています. \n"
"高層ビルの上には着陸場があり, そこを目指します. \n"
"\n"
"降り立つと, Formalosophenが走り寄ってきました. 彼は腕を大きく振っています. \n"
"\n"
"**受付係**：いえいえ, 下でお待ちしていますよ. \n"
"\n"
"彼は腕を下ろします. \n"
"\n"
"**受付係**：まあ, いいでしょう. まずはこんにちは! \n"
"私はただの管理人です. \n"
"大勢の代表団がお待ちですが, もちろん向こうのオフィスビルです. \n"
"こちらはただの宿泊棟です. さあ, 連れて行きましょう. すぐですよ. \n"
"\n"
"彼は1階下へ案内し, 「輸送カプセル」に乗るよう促します. 各自1つずつです. \n"
"\n"
"**受付係**：このカプセルで滑りながら向かいます. \n"
"心配ありません, 線路は空いています! \n"
"残念ながら衝突事故が時々ありますが, 今は大丈夫. \n"
"他の皆さんはもう向こうにいますよ!"
msgstr ""

#: Game.Levels.Mono.L01_Injective
msgid ""
msgstr ""

#: Game.Levels.Mono.L01_Injective
msgid "最上階には実際, 再び多くのFormalosophenが集まっています. \n"
"彼らはあなた方を喜んで歓迎し, すぐに本題に入ります."
msgstr ""

#: Game.Levels.Mono.L01_Injective
msgid "**Robo**: `Injective` はあなたが期待するように定義されています: `∀ {a b : U}, f a = f b → a = b`. \n"
"私を信用しないなら, `unfold`で簡単に確認できます."
msgstr ""

#: Game.Levels.Mono.L01_Injective
msgid "**Robo**:  `intro a b`から始めてみてはどうでしょう."
msgstr ""

#: Game.Levels.Mono.L01_Injective
msgid "**Robo**: 今こそ`«{f}»`の定義を使って仮定`«{ha}»`を簡略化すべきだと思います."
msgstr ""

#: Game.Levels.Mono.L01_Injective
msgid "Formalosophenたちは, あなた方の仕事をよくやったと評価しています."
msgstr ""

#: Game.Levels.Mono.L02_InjectiveNeIff
msgid ""
msgstr ""

#: Game.Levels.Mono.L02_InjectiveNeIff
msgid ""
msgstr ""

#: Game.Levels.Mono.L02_InjectiveNeIff
msgid "**Robo**: ここでは`Injective f`の定義を使う代わりに, 単射性の等価な記述`a ≠ b → f a ≠ f b`を使うことで短縮できます. \n"
"Leanではこれは`Injective.ne_iff`の一部です: 単射写像に対して`f a ≠ f b ↔ a ≠ b`が成り立ちます."
msgstr ""

#: Game.Levels.Mono.L02_InjectiveNeIff
msgid "**Robo**: `decide`?"
msgstr ""

#: Game.Levels.Mono.L02_InjectiveNeIff
msgid ""
msgstr ""

#: Game.Levels.Mono.L03_NotInjective
msgid ""
msgstr ""

#: Game.Levels.Mono.L03_NotInjective
msgid ""
msgstr ""

#: Game.Levels.Mono.L03_NotInjective
msgid "**Du**: 与えられた関数は以下の形式です:\n"
"$$\n"
"f(n) = \\begin{cases}\n"
"n^2 & \\text{nが偶数の場合} \\\\\n"
"n+1 & \\text{それ以外の場合}\n"
"\\end{cases}\n"
"$$\n"
"そして`f + f`とは何ですか? \n"
"\n"
"**Robo**: これは`ℕ → ℕ`の関数で, 各点で`f`の2倍の値を取ります."
msgstr ""

#: Game.Levels.Mono.L03_NotInjective
msgid "**Robo**: まず`Injective`を`unfold`で展開してみましょう. すると`¬ ∀`…と表示されます"
msgstr ""

#: Game.Levels.Mono.L03_NotInjective
msgid "**Robo**: `push_neg`を覚えていますか?"
msgstr ""

#: Game.Levels.Mono.L03_NotInjective
msgid "**Du** つまり反例を挙げればいいんですよね? \n"
"\n"
"**Robo** その通り! どの2つの数字を使いますか?"
msgstr ""

#: Game.Levels.Mono.L03_NotInjective
msgid "**Robo**: ここでは具体的な値なので, `decide`で解決できるかもしれません"
msgstr ""

#: Game.Levels.Mono.L03_NotInjective
msgid ""
msgstr ""

#: Game.Levels.Mono.L04_Diagonal
msgid ""
msgstr ""

#: Game.Levels.Mono.L04_Diagonal
msgid ""
msgstr ""

#: Game.Levels.Mono.L04_Diagonal
msgid "**あなた**: diagの定義には再び2つの矢印が連なっています. まず頭の中で整理する必要があります. \n"
"\n"
"**Robo**: 最初に括弧を付けましょう: `A → (Fin (n + 1) → A)`. つまりdiagはAから集合Fin (n + 1) → Aへの写像です. \n"
"`Fin (n+1)`は集合$\\{0,1,…,n\\}$であり, `Fin (n + 1) → A`は$\\{0,1,…,n\\}$から$A$への写像の集合です. \n"
"\n"
"**あなた**: ええと…そのような写像は実際にはAの要素の(n+1)タプルに他なりませんね? \n"
"\n"
"**Robo**: そう考えることもできます. \n"
"\n"
"**あなた**: わかりました. 与えられているのはAから$A^{n+1}$への写像diagです. そしてそれは…ああ, なぜこれがdiagと呼ばれるのかわかります."
msgstr ""

#: Game.Levels.Mono.L04_Diagonal
msgid "**あなた**: それとも違うのでしょうか? もう一度分解してもらえますか? \n"
"\n"
"**Robo**: 写像diagは要素aを, すべてのインデックス$i \\in \\{0,1,…,n\\}$を$a$に写す写像に送ります. \n"
"あなたの解釈では, これはa ↦ (a,…,a)という写像です."
msgstr ""

#: Game.Levels.Mono.L04_Diagonal
msgid "**Robo**: どうしてもわからない時は, まず `unfold Injective` から始めるのが良いでしょう."
msgstr ""

#: Game.Levels.Mono.L04_Diagonal
msgid "**Robo**: `«{h}»` の写像を `Fin (n + 1)` の要素で評価してみてはどうでしょうか? おそらく `congr_fun` が何らかの形で役立つかもしれません."
msgstr ""

#: Game.Levels.Mono.L04_Diagonal
msgid "**Robo**: あなたの「タプル」 `diag «{a₁}»` と `diag «{a₂}»` は実際には `Fin (n + 1) → A` の2つの写像であることを思い出してください. \n"
"これらを `Fin (n + 1)` の要素で評価してみてはどうでしょうか? おそらく `congr_fun` が何らかの形で役立つかもしれません."
msgstr ""

#: Game.Levels.Mono.L05_StrictMono
msgid ""
msgstr ""

#: Game.Levels.Mono.L05_StrictMono
msgid ""
msgstr ""

#: Game.Levels.Mono.L05_StrictMono
msgid "**あなた**: うーん, これは少し難しいですね…\n"
"\n"
"**Robo**: 私も今は良いアイデアが浮かびません. \n"
"\n"
"すると観衆の中から誰かが囁きます: `StrictMono`…\n"
"\n"
"**Robo**: ああ, そうですね. `StrictMono.injective`という補題があります:\n"
"厳密単調な写像はすべて単射です. \n"
"そして写像が単調であることを示すための補題もたくさんあります. \n"
"例えば:\n"
"\n"
"`StrictMono.add` - 2つの厳密単調写像の和は再び厳密単調です\n"
"\n"
"`Odd.strictMono_pow` - 奇数の`n`に対して`x ↦ x ^ n`は厳密単調です\n"
"\n"
"これで試してみましょうか?"
msgstr ""

#: Game.Levels.Mono.L05_StrictMono
msgid "**Robo**: `apply`が使えますよ"
msgstr ""

#: Game.Levels.Mono.L05_StrictMono
msgid "**Robo**: この方法は難しすぎるようです. 最初からやり直した方が良さそうです!"
msgstr ""

#: Game.Levels.Mono.L05_StrictMono
msgid "**Robo**: この方法は難しすぎるようです. 最初からやり直した方が良さそうです!"
msgstr ""

#: Game.Levels.Mono.L05_StrictMono
msgid "**あなた**: `Odd 3`. これは自明じゃないですか? ちょっと待って!"
msgstr ""

#: Game.Levels.Mono.L05_StrictMono
msgid "**あなた**: はっ! そしてこの部分はおそらくまた初等的に解けるでしょう"
msgstr ""

#: Game.Levels.Mono.L05_StrictMono
msgid "**あなた**: それとも…? \n"
"\n"
"**Robo**: いえいえ, できますよ. `unfold`で`StrictMono`の定義を覗いてみてください"
msgstr ""

#: Game.Levels.Mono.L05_StrictMono
msgid "Jede strikt monotone Abbildung (zwischen geeigneten Definitions- und Wertebereichen) ist injektiv."
msgstr ""

#: Game.Levels.Mono.L05_StrictMono
msgid "Für ungerades `n` ist `x ↦ x ^ n` strikt monoton.\n"
"\n"
"*Bemerkung*: Hat man `h_odd : Odd n` als Annahme, so kann man statt `Odd.strictMono_pow h_odd` auch einfach `h_odd.strictMono_pow` schreiben."
msgstr ""

#: Game.Levels.Mono.L05_StrictMono
msgid "Sind `f` und `g` beide strikt monoton sind, so ist auch `f + g` strikt momonton."
msgstr ""

#: Game.Levels.Mono.L05_StrictMono
msgid ""
msgstr ""

#: Game.Levels.Mono.L06_StrictMono
msgid ""
msgstr ""

#: Game.Levels.Mono.L06_StrictMono
msgid "どうやら誰かが`StrictMono.injective`が予測されていたことに気づいたようです. \n"
"今, 彼らはその証明を見たいと思っています."
msgstr ""

#: Game.Levels.Mono.L06_StrictMono
msgid "**Robo**: まずは古典的に, `Injective f`から変数と仮定を導入してみては?"
msgstr ""

#: Game.Levels.Mono.L06_StrictMono
msgid "**Robo**: 次に場合分けをしてみましょう. `lt_trichotomy`を覚えていますか?"
msgstr ""

#: Game.Levels.Mono.L07_SuccHasLeftInv
msgid ""
msgstr ""

#: Game.Levels.Mono.L07_SuccHasLeftInv
msgid ""
msgstr ""

#: Game.Levels.Mono.L07_SuccHasLeftInv
msgid "**あなた**: どうやら, 写像 `n ↦ n + 1` が左逆元を持つと主張されているようです. \n"
"そこで, 単純に `n ↦ n - 1` という写像を考えればいいのですが… `n = 0` の場合はうまくいきません. \n"
"\n"
"**Robo**: `if … then … else` を使って場合分けしてもいいけど, 実際にはそれすら必要ありません. Leanでは `0 - 1` も `ℕ` に属します. \n"
"\n"
"**あなた**: え…! ? \n"
"\n"
"**Robo**: はい. これは単純に `0` と定義されています."
msgstr ""

#: Game.Levels.Mono.L07_SuccHasLeftInv
msgid "**Robo**: 良さそうですね. でも, この分岐は全く不要です. \n"
"単に `n ↦ n - 1` を使っても大丈夫ですよ. 試してみて!"
msgstr ""

#: Game.Levels.Mono.L07_SuccHasLeftInv
msgid "**Robo**: 良さそうですね. でも, この分岐は全く不要です. \n"
"単に `n ↦ n - 1` を使っても大丈夫ですよ. 試してみて!"
msgstr ""

#: Game.Levels.Mono.L07_SuccHasLeftInv
msgid "**Robo**: 良さそうですね. でも, この分岐は全く不要です. \n"
"単に `n ↦ n - 1` を使っても大丈夫ですよ. 試してみて!"
msgstr ""

#: Game.Levels.Mono.L07_SuccHasLeftInv
msgid "**あなた**: まだショックを受けています. \n"
"  ここでは数学をやっていると思っていたのに, \n"
"  なぜ `0 - 1` が `0` になるんですか? \n"
"\n"
"  **Robo**: 見方の問題です. あなたは `n ↦ n - 1` を正の自然数でのみ定義された写像と考えています. \n"
"  Leanでは `n ↦ n - 1` は全ての自然数で定義された写像で, `0` を `0` に送ります. \n"
"  なぜでしょう. 結局この写像は正の数にしか適用されないので, あなたの解釈とLeanの解釈は幸いにも一致しています."
msgstr ""

#: Game.Levels.Mono.L08_RightInvOfLeftInv
msgid ""
msgstr ""

#: Game.Levels.Mono.L08_RightInvOfLeftInv
msgid ""
msgstr ""

#: Game.Levels.Mono.L08_RightInvOfLeftInv
msgid "**あなた**: ここには何が書いてあるの? \n"
"\n"
"**Robo**: 射影`f`が単射で, 写像`g`に対して左逆元である場合, 同じ写像に対して右逆元でもあります."
msgstr ""

#: Game.Levels.Mono.L09_InjOfHasLeftInv
msgid ""
msgstr ""

#: Game.Levels.Mono.L09_InjOfHasLeftInv
msgid ""
msgstr ""

#: Game.Levels.Mono.L09_InjOfHasLeftInv
msgid ""
msgstr ""

#: Game.Levels.Mono.L09_InjOfHasLeftInv
msgid "**あなた**: 左逆元を持つ写像は単射です. 聞いたことがあるような気がします…"
msgstr ""

#: Game.Levels.Mono.L09_InjOfHasLeftInv
msgid "**Robo**: たぶん`congr_arg g`で何かできる?"
msgstr ""

#: Game.Levels.Mono.L09_InjOfHasLeftInv
msgid "**Robo**: よくできました! もうすぐ終わりそうですね…"
msgstr ""

#: Game.Levels.Mono.L10_Auxiliary
msgid ""
msgstr ""

#: Game.Levels.Mono.L10_Auxiliary
msgid ""
msgstr ""

#: Game.Levels.Mono.L10_Auxiliary
msgid "**Du**:  私たちは今クァンタスに戻ったの? とにかく：`a`が存在するか, 存在しないかのどちらかで, これはトートロジーのように見える. \n"
"\n"
"**Robo**:  ゆっくり! 暗黙の括弧に注意する必要がある. もっと括弧を付けて書き直してみよう：\n"
"```\n"
"∀ b : B, ∃ a : A,\n"
"( f a = b   ∨   ¬ ∃ a' : A , f a' = b )\n"
"```"
msgstr ""

#: Game.Levels.Mono.L10_Auxiliary
msgid "**Robo**:  まず最初に`obtain`を使って`A`から何か要素を取得してみては? \n"
"要素が存在することはわかっているからね."
msgstr ""

#: Game.Levels.Mono.L10_Auxiliary
msgid "**Robo**:  さて, `by_cases`を使って`«{b}»`が原像を持つかどうかで場合分けしてみたらどうかな."
msgstr ""

#: Game.Levels.Mono.L11_InjHasLeftInv
msgid ""
msgstr ""

#: Game.Levels.Mono.L11_InjHasLeftInv
msgid ""
msgstr ""

#: Game.Levels.Mono.L11_InjHasLeftInv
msgid ""
msgstr ""

#: Game.Levels.Mono.L11_InjHasLeftInv
msgid "**あなた**: なるほど. エポソ派は, 写像が全射であることと右逆元を持つことが同値であることを証明したかったのですね. \n"
"そしてここのモノソ派は, 写像が単射であることと左逆元を持つことが同値であることを証明したかったのですね. \n"
"\n"
"**Robo**: はい, ただし彼らはこの追加条件`Nonempty A`が必要な点が違います."
msgstr ""

#: Game.Levels.Mono.L11_InjHasLeftInv
msgid "**あなた**: 具体的に左逆元をどう構築すればいいか分かりません. \n"
"\n"
"**Robo**: 先ほど証明した命題を思い出してください: ` ∀ b : B, ∃ a : A, …`\n"
"これがあれば, おそらく`choose`を使って求められる左逆元を選択できます. \n"
"ただ残念ながらこの命題には名前がついていません. \n"
"おそらく`have`で再度定式化し, 証明し直す必要があるでしょう."
msgstr ""

#: Game.Levels.Mono.L11_InjHasLeftInv
msgid "**Robo**: これは前に証明した内容ですね…しかし保存し忘れていました. \n"
"証明を覚えていますか?"
msgstr ""

#: Game.Levels.Mono.L11_InjHasLeftInv
msgid "再び大きな拍手を受けて, あなた方は見送られます. \n"
"帰路のための輸送カプセルはまたしてもありません. \n"
"しかし, それほど遠くもないでしょう."
msgstr ""

#: Game.Levels.Mono
msgid "Mono"
msgstr ""

#: Game.Levels.Mono
msgid "次の惑星には再び2つの高層ビルが並んで建っています. \n"
"片方は細く高く, もう片方は少し幅広で低い建物です. \n"
"そして再びそれらは配管システムで繋がっています──\n"
"おそらくまた何らかの輸送カプセルシステムがあるのでしょう. \n"
"エポでの経験を踏まえ, 今回はまっすぐ低い方の建物を目指し, 屋上に着陸しました. \n"
"\n"
"**受付係**: いやいや, そうじゃありません. みんなが手を振っているのを見ませんでしたか? \n"
"ここはただの宿泊棟です. 私たちは昼間はいつも向こうのオフィスタワーにいます. \n"
"まあいい, とにかくここに来たのですね. まずはようこそ! \n"
"\n"
"あなたたちはそれぞれ彼の4本の手を握ります. \n"
"\n"
"**受付係**: せっかくだから, 私たちのユニークな交通システムを紹介させてください. \n"
"あなたたちはエポから来たんですよね? \n"
"そこからは悪い話ばかり聞きます. \n"
"2日に1回は事故が起きているとか. \n"
"彼らは配管をきちんと整理できていないのです. \n"
"私たちは何年も無事故です! \n"
"\n"
"4階下へ降ります. \n"
"そこで再び各自にカプセルが割り当てられ, \n"
"静かに上昇してオフィスタワーへと向かいます. \n"
"どうやって動いているのかは謎のままです. \n"
"\n"
"**Robo**: あら. ここにも誰もいませんね! \n"
"\n"
"**受付係**: もちろんです. みんな最上階にいます. \n"
"そして全ての階が配管で行けるわけではありません. \n"
"でももうすぐ着きますよ. あと2つ階段を上がるだけです."
msgstr ""

#: Game.Levels.Samarkand.L01_ImagePreimage
msgid ""
msgstr ""

#: Game.Levels.Samarkand.L01_ImagePreimage
msgid "**Arapuka**: 私が長い間考えていることがいくつかあります. \n"
"もしかしたらあなたたちが助けてくれるかもしれません. 例えば：…\n"
"\n"
"彼女はあなたたちに命題を口述します. Roboがそれを書き留めます."
msgstr ""

#: Game.Levels.Samarkand.L01_ImagePreimage
msgid ""
msgstr ""

#: Game.Levels.Samarkand.L01_ImagePreimage
msgid "**Robo**: ここの記法について説明する必要があると思います. \n"
"明らかに写像 `f : A → B` が与えられています. \n"
"部分集合 `S` の `A` に対する\n"
"```\n"
"f '' S = {f a | a ∈ S}\n"
"= {b | ∃ a ∈ S, f a = b}\n"
"```\n"
"は `f` による像です. そして部分集合 `T` の `B` に対する\n"
"```\n"
"f ⁻¹' T = { a | f a ∈ T}\n"
"```\n"
"は `f` による原像です."
msgstr ""

#: Game.Levels.Samarkand.L01_ImagePreimage
msgid "**Robo:** 包含関係を示すには, 左辺から要素を取り出し, 右辺にあることを示します. \n"
"まず `intro b` から始めてみましょう."
msgstr ""

#: Game.Levels.Samarkand.L01_ImagePreimage
msgid "**Robo**: 仮定 `«{hb}»` をより基本的な式に変換するには, `simp` を適用できます."
msgstr ""

#: Game.Levels.Samarkand.L01_ImagePreimage
msgid "**Arapuka**: 素晴らしい."
msgstr ""

#: Game.Levels.Samarkand.L02_ImageMap
msgid "Bild/Urbild"
msgstr ""

#: Game.Levels.Samarkand.L02_ImageMap
msgid "Arapukaがもう一つ課題を出しています."
msgstr ""

#: Game.Levels.Samarkand.L02_ImageMap
msgid "**あなた**: ああ! つまり, この''のような煩わしい記法が嫌なら, 単に`image`と書いてもいいんだ? \n"
"\n"
"**Robo**: いいえ, よく見てください. ここでの`image f`は写像です. \n"
"これはもちろん, Aの部分集合をBの対応する像集合に送る写像で, \n"
"```\n"
"image f = fun S ↦ f '' S\n"
"```\n"
"つまり`image f`は`f ''`で表現できますが, 逆はできません."
msgstr ""

#: Game.Levels.Samarkand.L02_ImageMap
msgid "**Robo**: 2つの写像の一致を示す必要があります. `funext`を覚えていますか?"
msgstr ""

#: Game.Levels.Samarkand.L02_ImageMap
msgid "**Robo**: ああ, いや. これは複雑すぎます. 明示的に`funext S`と書いた方がいいです."
msgstr ""

#: Game.Levels.Samarkand.L02_ImageMap
msgid "**Robo**: 今度は2つの集合の等価性を示す必要があります - `ext`が魔法の言葉です."
msgstr ""

#: Game.Levels.Samarkand.L02_ImageMap
msgid "**Robo**: これはきっと簡単に簡略化できるでしょう…"
msgstr ""

#: Game.Levels.Samarkand.L02_ImageMap
msgid "**Arapuka**: 素敵, 素敵."
msgstr ""

#: Game.Levels.Samarkand.L03_SurjectiveRange
msgid "Range of Surjection"
msgstr ""

#: Game.Levels.Samarkand.L03_SurjectiveRange
msgid ""
msgstr ""

#: Game.Levels.Samarkand.L03_SurjectiveRange
msgid "**Robo**: ここで`range f`は`f`の全画像集合です:\n"
"```\n"
"range f = {f a | a : A}\n"
"= {  b | ∃ a, f a = b}\n"
"```\n"
"これは基本的に`f '' univ`の別の書き方です. \n"
"これを使うには`mem_range`が便利です:\n"
"```\n"
"x ∈ range f ↔ ∃ a, f a = b\n"
"```"
msgstr ""

#: Game.Levels.Samarkand.L03_SurjectiveRange
msgid "**Robo**: `consturctor`から始めてみましょう."
msgstr ""

#: Game.Levels.Samarkand.L03_SurjectiveRange
msgid "**Robo**: また集合の等式を示す必要がありますね? つまり`ext`です."
msgstr ""

#: Game.Levels.Samarkand.L03_SurjectiveRange
msgid ""
msgstr ""

#: Game.Levels.Samarkand.L03_SurjectiveRange
msgid "**Arapuka**: これもきれいですね. \n"
"\n"
"  **Robo**: ところで, あなたはこの惑星全体を絵で埋め尽くしたんですか? \n"
"\n"
"  **Arapuka**: いいえ. これは世代を超えた課題です. \n"
"  最初の模様要素は私の高祖祖父が刻みました. \n"
"  実際に何世代遡ればいいのか正確には分かりません. \n"
"  ましてや, 原初の模様がどこから来たのかなどなおさらです."
msgstr ""

#: Game.Levels.Samarkand.L04_SurjectiveImagePreimage
msgid ""
msgstr ""

#: Game.Levels.Samarkand.L04_SurjectiveImagePreimage
msgid "**Arapuka**:  これも手伝ってもらえるかな?"
msgstr ""

#: Game.Levels.Samarkand.L04_SurjectiveImagePreimage
msgid ""
msgstr ""

#: Game.Levels.Samarkand.L04_SurjectiveImagePreimage
msgid "**あなた**:  これさっきもやったんじゃない? \n"
"\n"
"**Robo**:  いいえ. さっきは包含関係 `image_preimage_subset` だけでした：\n"
"```\n"
"f '' (f ⁻¹' T) ⊆ T\n"
"```\n"
"今回は等号を示しますが, `f` が全射であるという追加の仮定があります."
msgstr ""

#: Game.Levels.Samarkand.L04_SurjectiveImagePreimage
msgid "**Arapuka**:  本当に助かります!"
msgstr ""

#: Game.Levels.Samarkand.L05_InjectiveFibre
msgid "Range of Injective"
msgstr ""

#: Game.Levels.Samarkand.L05_InjectiveFibre
msgid "**Arapuka**: 私にも単射写像について質問があります."
msgstr ""

#: Game.Levels.Samarkand.L05_InjectiveFibre
msgid ""
msgstr ""

#: Game.Levels.Samarkand.L05_InjectiveFibre
msgid "**あなた**: `∃! a` でまず使用したい要素 `a` を構築します…\n"
"\n"
"**Robo**: …そして `use a` と `simp` を適用します. その通りです."
msgstr ""

#: Game.Levels.Samarkand.L05_InjectiveFibre
msgid "Arapukaはまだじっと動かずにいますが, 幸せそうに見えます."
msgstr ""

#: Game.Levels.Samarkand.L06_PreimageNonempty
msgid ""
msgstr ""

#: Game.Levels.Samarkand.L06_PreimageNonempty
msgid "**Arapuka**: では, これはどうかな?"
msgstr ""

#: Game.Levels.Samarkand.L06_PreimageNonempty
msgid "**あなた**: つまり, `b`のファイバーが空でないのは, `b`に原像があるときだけ, ってことですね. \n"
"またしてもかなり自明なことです. \n"
"\n"
"**Robo**: はい, 表記法を除けば. \n"
"幸い, `eq_empty_iff_forall_not_mem`は既に証明済みです. \n"
"これを使うには, 不等号を展開する必要があります. 例えば`unfold Ne`で簡単にできます."
msgstr ""

#: Game.Levels.Samarkand.L06_PreimageNonempty
msgid "**Arapuka**: 君たちの言う通りだ. 自分でも気付くべきだった."
msgstr ""

#: Game.Levels.Samarkand.L07_LeftInvPreimage
msgid "Preimage of the inverse"
msgstr ""

#: Game.Levels.Samarkand.L07_LeftInvPreimage
msgid "**Arapuka**: さて, 本当に難しい課題がまだ残っています."
msgstr ""

#: Game.Levels.Samarkand.L07_LeftInvPreimage
msgid "**あなた**: 考えてみよう…∪"
msgstr ""

#: Game.Levels.Samarkand.L07_LeftInvPreimage
msgid "**Arapuka**: わあ! あなたたちは本当に素晴らしいです."
msgstr ""

#: Game.Levels.Samarkand.L08_Preimage_Injective
msgid "Preimage of surjective is injective"
msgstr ""

#: Game.Levels.Samarkand.L08_Preimage_Injective
msgid "**Arapuka**: この予想について, さらに助けてもらえるでしょうか?"
msgstr ""

#: Game.Levels.Samarkand.L08_Preimage_Injective
msgid ""
msgstr ""

#: Game.Levels.Samarkand.L08_Preimage_Injective
msgid "**Robo**: 写像が全射であることと, 部分集合をその部分集合の下での原像に送る誘導写像`preimage f`が単射であることは同値ですか? \n"
"これは本当に正しいのでしょうか? \n"
"\n"
"**あなた**: そうだと思います. 以前見たことがあります. \n"
"\n"
"**Robo**: それでは, 始めましょう!"
msgstr ""

#: Game.Levels.Samarkand.L08_Preimage_Injective
msgid "**Arapuka**: 素晴らしい!  興奮して飛び上がりたい気分です. \n"
"  しかしもちろんそれはできません. そうするとパターンが台無しになってしまいます. \n"
"\n"
"  **Robo**: あとどれくらい時間があるのですか? \n"
"\n"
"  **Arapuka**: ここにあと3年と22日7時間35分です. \n"
"\n"
"  **Robo**: ああ…\n"
"\n"
"  **あなた**: そして, パターンが合うようにその後どこに行けばいいのか, どうやって知るのですか? \n"
"\n"
"  **Arapuka**: ああ! \n"
"\n"
"  Arapukaの顔に大きな笑みが広がります. \n"
"\n"
"  **Arapuka**: それがまさに芸術なのです!"
msgstr ""

#: Game.Levels.Samarkand
msgid "Samarkand"
msgstr ""

#: Game.Levels.Samarkand
msgid "遠くに非常にカラフルな惑星が見えてきました. \n"
"近づくと, その表面の大部分が精巧な幾何学模様で装飾されているのがわかります. \n"
"しかし, 装飾されていない真っ白な領域もいくつかあります. \n"
"あなたはその白いエリアの一つに着陸しました. \n"
"\n"
"**あなた**: やあ, 誰かいる? \n"
"\n"
"惑星の表面は完璧な球体のようです. あらゆる方向に地平線が見えます. \n"
"誰もいません. 引き返そうとした時, 何かに気が付きました. \n"
"\n"
"**あなた**: Robo, あそこを見て! 惑星にこぶがあるよ! \n"
"\n"
"「こぶ」は小さなカメであることが判明しました. \n"
"模様の端近くの色付きの地面に横たわっています. \n"
"慎重に模様のある地面に足を踏み入れます. 色は乾いているようです. \n"
"\n"
"**Arapuka**: こんにちは, 二人とも! 近くに来てください! 訪問者が来てくれて嬉しいです. \n"
"\n"
"**あなた**: こんなところで一人で何をしているの? \n"
"\n"
"**Arapuka**: 大きな芸術作品を作っているんです. \n"
"お腹の甲板が地面の模様を写し取るまでここに横たわっています. \n"
"それから, 模様がまだ完成していない場所まで歩いて行き, 白い惑星表面に模様を転写するまで横たわります. \n"
"時間がかかります. だから, お話し相手がいてくれると助かります. \n"
"\n"
"**あなた**: それはいいね."
msgstr ""

#: Game.Levels.Iso.L01_Bijective
msgid "Bijektivität"
msgstr ""

#: Game.Levels.Iso.L01_Bijective
msgid "**イソソソフ**: もちろん, 私たちもあなたたちのために準備しておきました."
msgstr ""

#: Game.Levels.Iso.L01_Bijective
msgid "**Robo** *(小声で)*: `Bijective f` は `Injective f ∧ Surjective f` と定義されています. \n"
"\n"
"**あなた**: それならとても簡単ですね!"
msgstr ""

#: Game.Levels.Iso.L01_Bijective
msgid "**イソソソフ**: 素晴らしい. それなら, ここは全部飛ばしてもいいと思います…\n"
"\n"
"彼は数枚の紙を脇に置いた."
msgstr ""

#: Game.Levels.Iso.L02_Inverse
msgid "Inverse"
msgstr ""

#: Game.Levels.Iso.L02_Inverse
msgid "**Isosoph**:  …そして本題に入りましょう."
msgstr ""

#: Game.Levels.Iso.L02_Inverse
msgid ""
msgstr ""

#: Game.Levels.Iso.L02_Inverse
msgid "**あなた**: 写像が全単射であることと, それに対する逆写像が存在することは同値です. \n"
"これは基本的に, EpoとMonoで既に示したことと同じです. \n"
"これらの主張を保存していましたか? \n"
"\n"
"**Robo**: はい, しかしここでそれらを展開すると眉を上げられるでしょう. \n"
"代わりに, しっかり考えて, それがどうだったか思い出しましょう."
msgstr ""

#: Game.Levels.Iso.L02_Inverse
msgid "**Robo**: まず`Bijective`を`obtain ⟨hinj, hsurj⟩  := «{h}»`で\n"
"`Injective`と`Surjective`に分解してみてください!"
msgstr ""

#: Game.Levels.Iso.L02_Inverse
msgid "**Robo**: 全射性から, 各`y : B`には原像`x : A`があることが分かります. \n"
"`choose`を使って逆写像を構築できませんか?"
msgstr ""

#: Game.Levels.Iso.L02_Inverse
msgid "まず`«{g}»`が`«{f}»`の右逆元であることを示すのが良いでしょう, \n"
"例えば`have hR : RightInverse «{g}» «{f}»`のように"
msgstr ""

#: Game.Levels.Iso.L02_Inverse
msgid "**Robo**: `simp [LeftInverse]`で証明目標を簡略化できます."
msgstr ""

#: Game.Levels.Iso.L02_Inverse
msgid "**Robo**: `intro`から始めてみては?"
msgstr ""

#: Game.Levels.Iso.L02_Inverse
msgid "**Robo**: `«{h}»`をできるだけ分解してください!"
msgstr ""

#: Game.Levels.Iso.L02_Inverse
msgid "**Robo**: ANDもさらに分解!"
msgstr ""

#: Game.Levels.Iso.L02_Inverse
msgid "**Robo**: 単射性が難しい部分です. まず`intro`から始めてみてください."
msgstr ""

#: Game.Levels.Iso.L02_Inverse
msgid "**あなた**: 引数`f a = f b`が等しいなら`g (f a) = g (f b)`も等しい—\n"
"どう言えばいいんだっけ? \n"
"\n"
"**Robo**: `f a = f b`があるなら, 単に`rw`を使えますよ."
msgstr ""

#: Game.Levels.Iso.L02_Inverse
msgid "**Robo**: ここでは`RightInverse`の仮定を`rw`で使えます."
msgstr ""

#: Game.Levels.Iso.L02_Inverse
msgid "Isosophたちはとても満足そうでした. \n"
"\n"
"**Robo**: 私たちはもう一度...カプセル化できますか? \n"
"\n"
"**Isosoph**: もちろん!  しかし順序よく進めましょう. \n"
"私たちが双方向でカプセルを使い始めてから, また事故が増えています. \n"
"\n"
"Roboはさらに3往復します. その後, あなたたちはさらに進みます."
msgstr ""

#: Game.Levels.Iso
msgid "Iso"
msgstr ""

#: Game.Levels.Iso
msgid "**あなた**: 見て, また高さが同じ2つのビルがある惑星だ! \n"
"\n"
"**Robo**: そうだね. でもどちらに着陸すればいいかわからなくなっちゃった. \n"
"\n"
"**あなた**: 左側で人々が手を振っているよ! \n"
"\n"
"というわけで左側に着陸しました. \n"
"しかし歓迎はあまり熱心ではありませんでした. \n"
"\n"
"**Isosoph**: こんにちは! \n"
"こんな人混みの中に着陸するなんてマナーがなっていません! \n"
"あそこに特別に着陸地点をマークしていたのに! \n"
"\n"
"**Robo**: すみません! 記号の意味がわかりませんでした. \n"
"\n"
"**Isosoph**: まあ無事でよかった! \n"
"あなたたちが少し変わっているとは聞いていました. \n"
"それでも私たちの素晴らしい交通システムを見せてあげましょう - フォルマロバース全体で最も先進的な公共交通システムです! \n"
"\n"
"実際, 特に先進的な点の1つは, この惑星では輸送カプセルを双方向に使用できることです. \n"
"あなたたちは何度か行ったり来たりします."
msgstr ""

#: Game.Levels.Piazza.L01_Mem__Set
msgid ""
msgstr ""

#: Game.Levels.Piazza.L01_Mem__Set
msgid "**Fin**:  ええ, もちろん. 例えばこれなんかどうでしょう."
msgstr ""

#: Game.Levels.Piazza.L01_Mem__Set
msgid "**あなた**: これで合ってる?\n"
"\n"
"**Robo**: たぶんね. かなり*tauto*的に見えるでしょ?"
msgstr ""

#: Game.Levels.Piazza.L01_Mem__Set
msgid "**Set**: 君たちも集合論に少し詳しいんだね?\n"
"\n"
"**Robo**: まあ, *ちょっと*ね."
msgstr ""

#: Game.Levels.Piazza.L02_Simp
msgid ""
msgstr ""

#: Game.Levels.Piazza.L02_Simp
msgid "**Mem**: これでどうかな?"
msgstr ""

#: Game.Levels.Piazza.L02_Simp
msgid "**Robo**: ここは`simp`を使うのが一番簡単だと思うよ."
msgstr ""

#: Game.Levels.Piazza.L02_Simp
msgid "**Robo**: `decide`を思い出して."
msgstr ""

#: Game.Levels.Piazza.L02_Simp
msgid ""
msgstr ""

#: Game.Levels.Piazza.L03_Ext__Set__Union__Inter
msgid ""
msgstr ""

#: Game.Levels.Piazza.L03_Ext__Set__Union__Inter
msgid "**Set**: もしこれが簡単すぎたなら——この発言を知っていますか?"
msgstr ""

#: Game.Levels.Piazza.L03_Ext__Set__Union__Inter
msgid "**あなた**:  `A B C : Set ℕ` ここでは正確には何を意味する?\n"
"\n"
"**Robo**:  それは単に, `A`, `B`, `C` が `ℕ` の*部分集合*であることを意味します.\n"
"\n"
"**あなた**:  `Set` は「部分集合」という意味?\n"
"\n"
"**Robo**:  そう言ってもいいでしょう, はい.\n"
"\n"
"**あなた**:  それなら, この主張は*知っている*かもしれません.\n"
"でも, どうやってここで証明できるかは全くわかりません.\n"
"\n"
"**Ext**:  私が教えられます! 魔法の言葉があります, それは私と全く同じ名前です! !\n"
"\n"
"**Robo**:  ああ, そうですね——\n"
"`ext x` は集合の等式 `A = B` を `x ∈ A ↔ x ∈ B` に置き換えます."
msgstr ""

#: Game.Levels.Piazza.L03_Ext__Set__Union__Inter
msgid "**Robo**:  そして今度も `simp` です."
msgstr ""

#: Game.Levels.Piazza.L03_Ext__Set__Union__Inter
msgid "**あなた**:  `simp` は実際には何をしているのですか?\n"
"\n"
"**Robo**:  `simp` は一般的に知られている等式や同値関係を探し,\n"
"一般的に簡略化と見なされ, 現在適用可能なものを探します.\n"
"`simp` が見つけたすべての簡略化を適用します.\n"
"今まさに, 例えば次の形式の簡略化がありました：\n"
"```\n"
"«{x}» ∈ «{A}» ∩ «{B}» ↔ «{x}» ∈ «{A}» ∧ «{x}» ∈ «{B}»\n"
"```\n"
"そして\n"
"```\n"
"«{x}» ∈ «{B}» ∪ «{C}» ↔ «{x}» ∈ «{B}» ∨ «{x}» ∈ «{C}».\n"
"```"
msgstr ""

#: Game.Levels.Piazza.L03_Ext__Set__Union__Inter
msgid "**Robo**:  残りはきっと `tauto` でできます."
msgstr ""

#: Game.Levels.Piazza.L03_Ext__Set__Union__Inter
msgid ""
msgstr ""

#: Game.Levels.Piazza.L04_Generalize__univ__eq_univ_iff_forall
msgid ""
msgstr ""

#: Game.Levels.Piazza.L04_Generalize__univ__eq_univ_iff_forall
msgid "**Sub:** 私もすでにいくつか学びました:"
msgstr ""

#: Game.Levels.Piazza.L04_Generalize__univ__eq_univ_iff_forall
msgid "**Du**:  `univ`って何ですか?\n"
"\n"
"**Robo**:  `univ`は最大部分集合です：すべての自然数を含みます.\n"
"\n"
"**Du**:  つまり単に`ℕ`ですか?\n"
"\n"
"**Robo**:  はい, でも違います. `univ : Set ℕ`は「ℕ全体」ですが, ℕの部分集合として扱われます.\n"
"\n"
"Ext, Fin, Set, Sub, Memがあなたを見つめています.\n"
"\n"
"**Set**:  これは混同するはずがないでしょう! ここにブルーベリーがあります,\n"
"これは全てのブルーベリーが入ったかごで, このブルーベリーはかごの中にあります.\n"
"\n"
"**Mem**:  同様に, 5は自然数です(`5 : ℕ`),\n"
"`univ : Set ℕ`は全ての自然数の集合で, `5`はこの集合に含まれます(`5 ∈ univ`).\n"
"何が混乱するのでしょうか?\n"
"\n"
"**Robo** (*あなたに*): 頭を悩ませないでください.\n"
"ここではまず`rw [eq_univ_iff_forall]`から始めることをお勧めします,\n"
"そうすれば求められていることが明確にわかります."
msgstr ""

#: Game.Levels.Piazza.L04_Generalize__univ__eq_univ_iff_forall
msgid "**Robo**: そして今度は`simp`です. 最初から`simp [eq_univ_iff_forall]`とすることもできました."
msgstr ""

#: Game.Levels.Piazza.L04_Generalize__univ__eq_univ_iff_forall
msgid "**Du**: 次は`by_cases h : Even n`ですか?\n"
"\n"
"**Robo**: はい, それでゴールに到達できます.\n"
"しかし実際には`Even x ∨ ¬Even x`はトートロジーです.\n"
"`tauto`に認識させるためには, 適切に抽象化する必要があります.\n"
"ここでは例えば以下のようにできます:\n"
"```\n"
"generalize h : (Even x) = A\n"
"```"
msgstr ""

#: Game.Levels.Piazza.L04_Generalize__univ__eq_univ_iff_forall
msgid ""
msgstr ""

#: Game.Levels.Piazza.L04_Generalize__univ__eq_univ_iff_forall
msgid ""
msgstr ""

#: Game.Levels.Piazza.L05_empty__eq_empty_iff_forall_not_mem
msgid ""
msgstr ""

#: Game.Levels.Piazza.L05_empty__eq_empty_iff_forall_not_mem
msgid "**Mem:** この発言もまた混乱させられると思いませんか?"
msgstr ""

#: Game.Levels.Piazza.L05_empty__eq_empty_iff_forall_not_mem
msgid "**あなた**: いいえ, `∅`は知っています. \n"
"\n"
"**Robo**: あなたが正しく理解していることを完全に確認するために, \n"
"`rw [eq_empty_iff_forall_not_mem]`で始めることもできます. \n"
"または, 早く終わらせたい場合は`simp [eq_empty_iff_forall_not_mem]`を使うこともできます."
msgstr ""

#: Game.Levels.Piazza.L05_empty__eq_empty_iff_forall_not_mem
msgid ""
msgstr ""

#: Game.Levels.Piazza.L05_empty__eq_empty_iff_forall_not_mem
msgid ""
msgstr ""

#: Game.Levels.Piazza.L06_Ext2__univ2
msgid ""
msgstr ""

#: Game.Levels.Piazza.L06_Ext2__univ2
msgid "**Ext**: 私は*この*方程式が好きです."
msgstr ""

#: Game.Levels.Piazza.L06_Ext2__univ2
msgid "**Robo**: 今回はまた単純に`ext`を使えばいいよ."
msgstr ""

#: Game.Levels.Piazza.L06_Ext2__univ2
msgid "**Robo**: そしてもちろん今度も`simp`だ."
msgstr ""

#: Game.Levels.Piazza.L06_Ext2__univ2
msgid "**あなた** *(Roboに向かって)*: どうしてextってextって言うの? \n"
"\n"
"  **Robo**: 少年がどこから名前を取ったかなんて, 私に分かるわけないでしょう? \n"
"\n"
"  **あなた**: いや, ここの`ext`のことだよ! \n"
"\n"
"  **Robo**: ああそう. 2つの集合が同じ要素を持つとき, そしてそのときに限り等しいという原理を, \n"
"  論理学者は*外延性*と呼んでいます. そしてFormalosophenたちはおそらく, \n"
"  長すぎるからって*ext*にしたんでしょうね."
msgstr ""

#: Game.Levels.Piazza.L07_antisymm_iff
msgid "Antisymmetrie"
msgstr ""

#: Game.Levels.Piazza.L07_antisymm_iff
msgid "**Set**: そして私はこの同値性が好きです."
msgstr ""

#: Game.Levels.Piazza.L07_antisymm_iff
msgid ""
msgstr ""

#: Game.Levels.Piazza.L07_antisymm_iff
msgid "**あなた**: はい, 一度そう習った覚えがあります\n"
"– 2つの集合が相互に含まれている場合, それらは等しいです."
msgstr ""

#: Game.Levels.Piazza.L07_antisymm_iff
msgid "**Robo**: わかりませんが, `constructor`から始めると思います."
msgstr ""

#: Game.Levels.Piazza.L07_antisymm_iff
msgid "**Robo**: `«{A}»`を`«{B}»`に置き換えてみてください."
msgstr ""

#: Game.Levels.Piazza.L07_antisymm_iff
msgid "**Robo**: ここからは先ほどのパターンが再び当てはまるはずです."
msgstr ""

#: Game.Levels.Piazza.L07_antisymm_iff
msgid ""
msgstr ""

#: Game.Levels.Piazza.L08_subset_iff
msgid ""
msgstr ""

#: Game.Levels.Piazza.L08_subset_iff
msgid "**Sub**: あなたの言う通りです. \n"
"訪問者にもう少し包含について質問してみましょう."
msgstr ""

#: Game.Levels.Piazza.L08_subset_iff
msgid ""
msgstr ""

#: Game.Levels.Piazza.L08_subset_iff
msgid "**Robo**: これは定義そのものですよ! \n"
"\n"
"**Robo** *(あなたへ)*: `tauto`を試してみてください. あるいは直接`rfl`でもいいです."
msgstr ""

#: Game.Levels.Piazza.L08_subset_iff
msgid ""
msgstr ""

#: Game.Levels.Piazza.L08_subset_iff
msgid ""
msgstr ""

#: Game.Levels.Piazza.L09_subset_iff2
msgid ""
msgstr ""

#: Game.Levels.Piazza.L09_subset_iff2
msgid "**Sub**: さてさて. ただの定義ですね! \n"
"では, このような包含関係で作業する場合どうすればいいのでしょうか?"
msgstr ""

#: Game.Levels.Piazza.L09_subset_iff2
msgid "**あなた**: ここで`ext`を使って議論することはできますか? \n"
"\n"
"**Robo**: いいえ, もっと簡単です. `intro a`でAの任意の要素を取り, \n"
"それがCに含まれることを示してください. \n"
"\n"
"ただし, まず`rw [subset_iff] at *`ですべての包含関係を展開して, \n"
"何が起こるか確認した方が良いかもしれません."
msgstr ""

#: Game.Levels.Piazza.L09_subset_iff2
msgid ""
msgstr ""

#: Game.Levels.Piazza.L10
msgid ""
msgstr ""

#: Game.Levels.Piazza.L10
msgid "**Mem**: 私ももう一度質問させてください!"
msgstr ""

#: Game.Levels.Piazza.L10
msgid "**Robo**: 私はまた`intro`から始めます."
msgstr ""

#: Game.Levels.Piazza.L10
msgid "**Robo**: もう一度`intro`を!"
msgstr ""

#: Game.Levels.Piazza.L10
msgid "**Mem**: はい, 素晴らしい! でもあなたたちは早く覚えましたね!"
msgstr ""

#: Game.Levels.Piazza.L11_erase
msgid ""
msgstr ""

#: Game.Levels.Piazza.L11_erase
msgid "**Mem**: ねえ, Fin, 何してるの? \n"
"\n"
"Finはグループで一番小さく, 今まで何も話していませんでした. \n"
"そして今, 隣の屋台からピスタチオを盗んだようです. \n"
"\n"
"**Fin**: ただの小さな練習だよ. \n"
"\n"
"**Mem**: どんな練習? \n"
"\n"
"Finは次のように説明します."
msgstr ""

#: Game.Levels.Piazza.L11_erase
msgid "**あなた**: ここでの`Finset`ってどういう意味? \n"
"\n"
"**Robo**: これは`A`がℕの*有限*部分集合に属することを意味します. \n"
"でも質問には実は関係ありません. \n"
"左側には`a`のない`A`, 右側にも`a`のない`A`があります."
msgstr ""

#: Game.Levels.Piazza.L11_erase
msgid ""
msgstr ""

#: Game.Levels.Piazza.L12_insert
msgid ""
msgstr ""

#: Game.Levels.Piazza.L12_insert
msgid "**終了**: 正解です. では, ピスタチオを元の場所に戻します."
msgstr ""

#: Game.Levels.Piazza.L12_insert
msgid ""
msgstr ""

#: Game.Levels.Piazza.L13_insert_erase
msgid ""
msgstr ""

#: Game.Levels.Piazza.L13_insert_erase
msgid "**Fin**: さて, みんなどう思う? これでまた全員のピスタチオが家に帰れたかな?"
msgstr ""

#: Game.Levels.Piazza.L13_insert_erase
msgid ""
msgstr ""

#: Game.Levels.Piazza.L13_insert_erase
msgid "**Fin**: «{b}» = a かどうかで場合分けしてみたらどうかな"
msgstr ""

#: Game.Levels.Piazza.L13_insert_erase
msgid "**Fin**: そうそう, そのやり方でいけるよ"
msgstr ""

#: Game.Levels.Piazza.L13_insert_erase
msgid "子供たちは笑いながら, あなたたちを囲むように輪を作り, 二人には理解できない言葉で歌を歌います. そして走り去っていきます. \n"
"\n"
"**Robo**: 私たち, もう飛び立てるみたいだね"
msgstr ""

#: Game.Levels.Piazza
msgid "Piazza"
msgstr ""

#: Game.Levels.Piazza
msgid "どうやら, あなたたちは交易が盛んな惑星に着陸したようです.\n"
"至る所に商人が立ち, 商品を売りさばいています.\n"
"あなたたちは好奇心でいくつかの屋台を眺めます.\n"
"見慣れた食べ物もあれば, そうでないものもたくさんあります.\n"
"しかし, すべてがきちんと分類されています.\n"
"ブルーベリー(? )の入った籠, トマトを連想させる赤い植物の入った箱,\n"
"小さなピンクの星形が入った開いた袋などがあります.\n"
"\n"
"何人かの子供たち――少なくとも子供のように振る舞う非常に小さなFormalosophenたち――があなたの足を踏みそうになります.\n"
"Roboが後ずさりすると, 彼らはあなたに気づき立ち止まります. 彼らは「Fin」「Ext」「Mem」「Set」「Sub」と名乗り, 好奇心旺盛そうです.\n"
"\n"
"**Fin**: ここで何してるの?\n"
"\n"
"**あなた**: ええと…ちょっと見て回ろうと思って.\n"
"\n"
"**Set**: 私たちは集合論を学ぶためにここに来ました. 親が私たちをここに置いていったんです.\n"
"\n"
"**Ext**: 教育目的ってことですね, まあ.\n"
"\n"
"**あなた**: で, もう何か学んだことはある?"
msgstr ""

#: Game
msgid "Robo(和訳)"
msgstr ""

#: Game
msgid "# このサイトについて\n"
"こちらは, 以下のサイトを和訳したものです. (2025/07/11)\n"
"https://adam.math.hhu.de/#/g/hhu-adam/robo\n"
"ただし, そのままの訳だと, 長くなる箇所があり, 多少意訳している.\n"
"\n"
"# ゲームオーバーそれともQED?\n"
"コンピュータ支援証明が「本物の」数学とどう違うか気になりますか? それならここがぴったりです! このゲームでは, 証明アシスタントLean 4と数学ライブラリmathlibの使い方を学べます. 例えば, 帰納法を使った総和公式の証明, 写像が全射であることと右逆元を持つことが同値であることの証明, 自然数の列が非可算無限であることの証明, 正方行列の空間におけるトレースの特徴付けなどを行います.\n"
"\n"
"インターフェースは簡略化されていますが, エディターモードを有効にすると,\n"
"Leanの標準IDEであるVSCodeとほぼ同じ感覚で使えます. スマートフォンやタブレットでは,\n"
"デフォルトのタイプライターモードのままで, 画面キーボードの自動補完/修正機能をオフにするのがおすすめです.\n"
"\n"
"旅を始めるには, 最初の惑星Logoをクリックしてください.\n"
"\n"
"# ゲームの進行状況\n"
"進行状況はブラウザのサイトデータとしてローカルに保存されます. これを削除すると進行状況が失われます!\n"
"多くのブラウザではサイトデータとクッキーが一緒に削除されますが,\n"
"メニューから進行状況をダウンロードして手動で保存することもできます.\n"
"\n"
"# ゲームルール\n"
"真剣にプレイしたい場合は「Rules: regular」を選択してください.\n"
"少し見て回りたいだけなら「Rules: relaxed」を選ぶと, 前のレベルをクリアしていなくてもどのレベルでもプレイできます.\n"
"\n"
"背景情報とクレジットは, メニューの「Game Info」で確認できます.\n"
"\n"
"# 最新情報\n"
"\n"
"【2025年3月28日】Formaloversumに新惑星「Euklid」が登場! その他にも多数の改善が加えられました.\n"
"とくに「Babylon」「Cantor」「Saturn」の各惑星や, 戦術・定義のドキュメントが強化されています.\n"
"Babylonでは, 今後は ℕ や ℤ の区間での総和を扱い, `Fin n` は使われません.\n"
"Saturnのラストには, 多項式的な平方和公式が登場します.\n"
"\n"
"【2025年3月18日】「Quantus」から新惑星「Saturn」が分離. Lunaはサイズアップし, Piazzaも全面的に再設計されました.\n"
"\n"
"【2025年2月20日】写像に特化した惑星群「Vieta」「Mono」「Epo」「Iso」「Samarkand」が完成しました.\n"
"\n"
"【2025年1月25日】お別れ用の惑星「Ciao」が追加されました."
msgstr ""

#: Game
msgid "このゲームは, 以下のリポジトリを和訳したものである. (2025/07/09)\n"
"[Robo](https://github.com/hhu-adam/Robo)\n"
"\n"
"ただし, 準拠した和訳ではない.\n"
"以下は, 元のGame Infoをそのまま載せている.\n"
"## Projekt ADAM\n"
"\n"
"Dieses Lernspiel wurde im Rahmen des Projekts\n"
"[ADAM: Anticipating the Digital Age of Mathematics](https://hhu-adam.github.io/)\n"
"an der Heinrich-Heine-Universität Düsseldorf entwickelt,\n"
"finanziert durch das Programm *Freiraum 2022* der *Stiftung Innovation in der Hochschullehre*.\n"
"\n"
"## Spielinhalt\n"
"\n"
"**Spoiler Alert** Auf [Github](https://github.com/hhu-adam/Robo?tab=readme-ov-file#overview-over-existing-content) findest du eine Übersicht über den groben mathematischen Inhalt aller Planeten.\n"
"\n"
"## Credits\n"
"\n"
"* **Projektleitung:** Marcus Zibrowius, Immi Halupczok\n"
"* **Game Engine:** Jon Eugster, Alexander Bentkamp, Patrick Massot – siehe [lean4game](https://github.com/leanprover-community/lean4game?tab=readme-ov-file#credits)\n"
"* **Levels:** Jon Eugster, Marcus Zibrowius, Sina Hazratpour\n"
"* **Konzept & Handlung:** Marcus Zibrowius\n"
"* **Illustrationen:** [Dušan Pavlić](https://www.behance.net/dusanpavlic#)\n"
"\n"
"## Kontakt\n"
"\n"
"Das Spiel wird laufend überarbeitet.\n"
"Wir freuen uns sehr über Erfahrungsberichte, Anregungen und Kritik,\n"
"zum Beispiel per Email an\n"
"[Marcus Zibrowius](https://www.math.uni-duesseldorf.de/~zibrowius/).\n"
"Wenn du spezifische Änderungswünsche hast oder Fehler findest, kannst du auch gern einen Issue auf GitHub erstellen:\n"
"\n"
"* zum Spielinhalt im [Robo repo](https://github.com/hhu-adam/Robo/issues)\n"
"* zum Spielserver im [lean4game repo](https://github.com/leanprover-community/lean4game/issues)."
msgstr ""

#: Game
msgid "QED"
msgstr ""

#: Game
msgid "Erkunde ein fremdes Universum mit deinem Smart-Elf Robo!"
msgstr ""

#: Game
msgid "Dieses Spiel illustriert Beweisführung mit Lean anhand verschiedener Themen aus der Eingangsphase des Bachelorstudiums Mathematik."
msgstr ""
